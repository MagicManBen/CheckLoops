/**
 * User Identification Utilities for CheckLoop
 * Provides consistent user identification across all pages
 */

/**
 * Get complete user profile with all necessary identifiers
 * @param {Object} supabase - Supabase client instance
 * @param {Object} user - Auth user object
 * @returns {Object} Complete user profile with all identifiers
 */
async function getUserProfile(supabase, user) {
  if (!user?.id) return null;
  
  try {
    // First try to use the unified view if it exists
    try {
      const { data: unified } = await supabase
        .from('master_users')
        .select('*')
        .eq('user_id', user.id)
        .maybeSingle();
      
      if (unified) {
        return {
          user_id: unified.user_id,
          email: unified.email,
          site_id: unified.site_id,
          full_name: unified.full_name || user.email?.split('@')[0] || 'Staff Member',
          nickname: unified.nickname,
          display_name: unified.display_name || unified.full_name || user.email?.split('@')[0] || 'Staff Member',
          role: unified.role || 'member',
          role_detail: unified.role_detail,
          team_id: unified.team_id,
          team_name: unified.team_name,
          avatar_url: unified.avatar_url,
          kiosk_user_id: unified.kiosk_user_id,
          onboarding_complete: unified.onboarding_complete || false
        };
      }
    } catch (viewError) {
      console.warn('Unified view not available, falling back to individual tables', viewError);
    }
    
    // Fallback to individual table queries
    let profile = null;
    let staffWelcome = null;
    let kioskUser = null;
    
    // Get main profile - handle case where avatar_url column might not exist
    try {
      const { data: p } = await supabase
        .from('master_users')
        .select('*')
        .eq('user_id', user.id)
        .maybeSingle();
      profile = p;
    } catch (profileError) {
      // If avatar_url column doesn't exist, try without it
      try {
        const { data: p } = await supabase
          .from('master_users')
          .select('user_id, site_id, full_name, nickname, role, onboarding_complete, created_at')
          .eq('user_id', user.id)
          .maybeSingle();
        profile = p;
      } catch (basicError) {
        console.warn('Profiles table access failed:', basicError);
      }
    }
    
    // Get staff welcome data
    try {
      const { data: sw } = await supabase
        .from('master_users')
        .select('*')
        .eq('user_id', user.id)
        .maybeSingle();
      staffWelcome = sw;
    } catch (staffWelcomeError) {
      console.warn('Staff welcome table access failed:', staffWelcomeError);
    }
    
    // Determine primary identifiers
    const siteId = profile?.site_id || staffWelcome?.site_id || user?.raw_user_meta_data?.site_id;
    const fullName = profile?.full_name || staffWelcome?.full_name || user?.raw_user_meta_data?.full_name;
    
    // Get kiosk user if data available
    if (siteId && fullName) {
      try {
        const { data: ku } = await supabase
          .from('master_users')
          .select('id, full_name, site_id')
          .eq('site_id', siteId)
          .eq('full_name', fullName)
          .maybeSingle();
        kioskUser = ku;
      } catch (kioskError) {
        console.warn('Kiosk user lookup failed:', kioskError);
      }
    }
    
    // Construct complete profile with fallbacks
    return {
      user_id: user.id,
      email: user.email,
      site_id: siteId,
      full_name: fullName || user.email?.split('@')[0] || 'Staff Member',
      nickname: profile?.nickname || staffWelcome?.nickname || null,
      display_name: profile?.nickname || staffWelcome?.nickname || fullName || user.email?.split('@')[0] || 'Staff Member',
      role: profile?.role || user?.raw_user_meta_data?.role || 'member',
      role_detail: staffWelcome?.role_detail || null,
      team_id: staffWelcome?.team_id || null,
      team_name: staffWelcome?.team_name || null,
      avatar_url: profile?.avatar_url || staffWelcome?.avatar_url || null,
      kiosk_user_id: kioskUser?.id || null,
      onboarding_complete: profile?.onboarding_complete || false,
      profile: profile,
      staff_welcome: staffWelcome,
      kiosk_user: kioskUser
    };
  } catch (error) {
    console.error('Error getting user profile:', error);
    // Return minimal profile on error
    return {
      user_id: user.id,
      email: user.email,
      site_id: user?.raw_user_meta_data?.site_id || null,
      full_name: user?.raw_user_meta_data?.full_name || user.email?.split('@')[0] || 'Staff Member',
      display_name: user?.raw_user_meta_data?.full_name || user.email?.split('@')[0] || 'Staff Member',
      role: user?.raw_user_meta_data?.role || 'member',
      onboarding_complete: false
    };
  }
}

/**
 * Create or update a submission with proper user identification
 * @param {Object} supabase - Supabase client instance
 * @param {Object} userProfile - User profile from getUserProfile
 * @param {Object} submissionData - Submission data to save
 * @returns {Object} Created submission
 */
async function createSubmission(supabase, userProfile, submissionData) {
  if (!userProfile?.user_id) {
    throw new Error('User profile required for submission');
  }
  
  // Ensure we have required fields
  const submission = {
    ...submissionData,
    user_id: userProfile.user_id,
    site_id: userProfile.site_id,
    staff_name: userProfile.full_name, // Keep for backward compatibility
    staff_id: userProfile.kiosk_user_id, // Link to kiosk user if exists
    submitted_by_user_id: userProfile.user_id // Track who submitted
  };
  
  // Remove null/undefined values
  Object.keys(submission).forEach(key => {
    if (submission[key] === null || submission[key] === undefined) {
      delete submission[key];
    }
  });
  
  const { data, error } = await supabase
    .from('submissions')
    .insert(submission)
    .select()
    .single();
    
  if (error) throw error;
  return data;
}

/**
 * Query submissions for a user (using user_id)
 * @param {Object} supabase - Supabase client instance
 * @param {Object} userProfile - User profile from getUserProfile
 * @param {Object} options - Query options (limit, offset, etc.)
 * @returns {Array} User's submissions
 */
async function getUserSubmissions(supabase, userProfile, options = {}) {
  if (!userProfile?.user_id) return [];
  
  const query = supabase
    .from('submissions')
    .select(options.select || '*')
    .eq('user_id', userProfile.user_id);
  
  // Add site filter if available
  if (userProfile.site_id) {
    query.eq('site_id', userProfile.site_id);
  }
  
  // Apply additional options
  if (options.limit) query.limit(options.limit);
  if (options.offset) query.range(options.offset, options.offset + (options.limit || 10) - 1);
  if (options.order) query.order(options.order.column || 'submitted_at', options.order);
  
  const { data, error } = await query;
  
  if (error) {
    console.error('Error fetching user submissions:', error);
    
    // Fallback to staff_name query for backward compatibility
    if (userProfile.full_name) {
      const fallback = await supabase
        .from('submissions')
        .select(options.select || '*')
        .eq('staff_name', userProfile.full_name)
        .eq('site_id', userProfile.site_id)
        .limit(options.limit || 10)
        .order('submitted_at', { ascending: false });
      
      if (!fallback.error) return fallback.data;
    }
    return [];
  }
  
  return data;
}

/**
 * Query submission details for a user
 * @param {Object} supabase - Supabase client instance
 * @param {Object} userProfile - User profile from getUserProfile
 * @param {Object} options - Query options
 * @returns {Array} User's submission details
 */
async function getUserSubmissionDetails(supabase, userProfile, options = {}) {
  if (!userProfile?.user_id) return [];
  
  // First try with user_id if the view supports it
  let query = supabase
    .from('v_submission_detail')
    .select(options.select || '*');
  
  // Check if view has user_id column by trying a limited query
  const { data: testData, error: testError } = await supabase
    .from('v_submission_detail')
    .select('*')
    .limit(0);
  
  // If view doesn't have user_id, fall back to staff_name
  if (testError?.message?.includes('user_id')) {
    query = query.eq('staff_name', userProfile.full_name);
  } else {
    // Try user_id first
    query = query.eq('user_id', userProfile.user_id);
  }
  
  if (userProfile.site_id) {
    query.eq('site_id', userProfile.site_id);
  }
  
  // Apply additional filters
  if (options.from_date) query.gte('submitted_at', options.from_date);
  if (options.to_date) query.lte('submitted_at', options.to_date);
  if (options.limit) query.limit(options.limit);
  if (options.order) query.order(options.order.column || 'submitted_at', options.order);
  
  const { data, error } = await query;
  
  if (error) {
    console.error('Error fetching submission details:', error);
    // Fallback to staff_name
    const fallback = await supabase
      .from('v_submission_detail')
      .select(options.select || '*')
      .eq('staff_name', userProfile.full_name)
      .eq('site_id', userProfile.site_id)
      .limit(options.limit || 50)
      .order('submitted_at', { ascending: false });
    
    if (!fallback.error) return fallback.data;
    return [];
  }
  
  return data;
}

/**
 * Get user achievements
 * @param {Object} supabase - Supabase client instance
 * @param {Object} userProfile - User profile from getUserProfile
 * @returns {Array} User's achievements
 */
async function getUserAchievements(supabase, userProfile) {
  if (!userProfile?.kiosk_user_id) return [];

  // Join user_achievements with achievements to get names/icons
  const { data, error } = await supabase
    .from('user_achievements')
    .select('achievement_key, status, progress_percent, unlocked_at, achievements!inner(key, name, description, icon, points, metadata)')
    .eq('kiosk_user_id', userProfile.kiosk_user_id);

  if (error) {
    console.error('Error fetching achievements:', error);
    return [];
  }

  return data || [];
}

/**
 * Ensure user profile exists and is complete
 * @param {Object} supabase - Supabase client instance
 * @param {Object} user - Auth user object
 * @param {Object} additionalData - Additional profile data
 * @returns {Object} Updated profile
 */
async function ensureUserProfile(supabase, user, additionalData = {}) {
  if (!user?.id) throw new Error('User ID required');
  
  // Check if profile exists
  const { data: existing } = await supabase
    .from('master_users')
    .select('*')
    .eq('user_id', user.id)
    .maybeSingle();
  
  if (existing) {
    // Update if additional data provided
    if (Object.keys(additionalData).length > 0) {
      const { data, error } = await supabase
        .from('master_users')
        .update(additionalData)
        .eq('user_id', user.id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    }
    return existing;
  }
  
  // Create new profile
  const newProfile = {
    user_id: user.id,
    site_id: additionalData.site_id || user?.raw_user_meta_data?.site_id || null,
    full_name: additionalData.full_name || user?.raw_user_meta_data?.full_name || user.email?.split('@')[0],
    nickname: additionalData.nickname || null,
    role: additionalData.role || user?.raw_user_meta_data?.role || 'member',
    avatar_url: additionalData.avatar_url || null,
    onboarding_complete: additionalData.onboarding_complete || false,
    created_at: new Date().toISOString()
  };
  
  const { data, error } = await supabase
    .from('master_users')
    .insert(newProfile)
    .select()
    .single();
  
  if (error) throw error;
  return data;
}

// Export for use in other scripts
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    getUserProfile,
    createSubmission,
    getUserSubmissions,
    getUserSubmissionDetails,
    getUserAchievements,
    ensureUserProfile
  };
}

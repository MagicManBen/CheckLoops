<!DOCTYPE html>
<html>
<head>
  <title>Supabase Schema Checker</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.js"></script>
  <style>
    body { font-family: monospace; padding: 20px; background: #1a1a1a; color: #0f0; }
    pre { background: #000; padding: 10px; border: 1px solid #0f0; overflow-x: auto; }
    .error { color: #f00; }
    .success { color: #0f0; }
    .warning { color: #ff0; }
    button { background: #0f0; color: #000; padding: 10px 20px; border: none; cursor: pointer; margin: 5px; }
    button:hover { background: #0a0; }
  </style>
</head>
<body>
  <h1>Supabase Schema Checker for NHS/CQC Integration</h1>
  <button onclick="checkSchema()">Check Database Schema</button>
  <button onclick="checkEdgeFunctions()">Check Edge Functions</button>
  <button onclick="generateMigration()">Generate Missing Columns SQL</button>
  <div id="output"></div>

  <script>
    const SUPABASE_URL = 'https://unveoqnlqnobufhublyw.supabase.co';
    const SUPABASE_ANON_KEY = 'sb_publishable_wpy7lxfbI2HwvsznlWJVKg_Zx7HnAc4';

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const requiredColumns = {
      // Core fields
      'location_id': 'text PRIMARY KEY',
      'location_name': 'text',
      'provider_id': 'text',
      'provider_name': 'text',

      // Raw JSON storage
      'location_source': 'jsonb',
      'provider_source': 'jsonb',

      // NHS specific fields
      'nhs_ods_data': 'jsonb',
      'last_nhs_update': 'timestamptz',
      'nhs_last_updated': 'timestamptz',
      'ods_code': 'text',

      // Address fields
      'address_line_1': 'text',
      'address_line_2': 'text',
      'town_city': 'text',
      'county': 'text',
      'postcode': 'text',
      'region': 'text',
      'uprn': 'text',

      // Geographic data
      'latitude': 'text',
      'longitude': 'text',

      // Contact info
      'main_phone_number': 'text',
      'website': 'text',
      'number_of_beds': 'integer',

      // Administrative
      'constituency': 'text',
      'local_authority': 'text',
      'inspection_directorate': 'text',

      // NHS/CCG/ICB
      'onspd_ccg_code': 'text',
      'onspd_ccg_name': 'text',
      'ods_ccg_code': 'text',
      'ods_ccg_name': 'text',
      'onspd_icb_code': 'text',
      'onspd_icb_name': 'text',

      // Registration and status
      'organisation_type': 'text',
      'location_type': 'text',
      'registration_date': 'text',
      'registration_status': 'text',
      'deregistration_date': 'text',
      'dormancy': 'text',
      'care_home': 'text',

      // Ratings
      'overall_rating': 'text',
      'current_ratings': 'jsonb',
      'key_question_ratings': 'jsonb',
      'last_inspection_date': 'text',
      'last_report_date': 'text',

      // Complex data
      'regulated_activities': 'jsonb',
      'relationships': 'jsonb',
      'location_types': 'jsonb',
      'gac_service_types': 'jsonb',
      'specialisms': 'jsonb',
      'inspection_categories': 'jsonb',
      'inspection_areas': 'jsonb',
      'reports': 'jsonb',
      'contacts': 'jsonb',

      // Provider fields
      'provider_type': 'text',
      'ownership_type': 'text',
      'companies_house_number': 'text',
      'provider_registration_date': 'text',
      'provider_registration_status': 'text',
      'provider_brand_id': 'text',
      'provider_brand_name': 'text',
      'provider_location_ids': 'jsonb',
      'provider_address_line_1': 'text',
      'provider_address_line_2': 'text',
      'provider_town_city': 'text',
      'provider_county': 'text',
      'provider_postcode': 'text',
      'provider_region': 'text',
      'provider_uprn': 'text',
      'provider_latitude': 'text',
      'provider_longitude': 'text',
      'provider_constituency': 'text',
      'provider_local_authority': 'text',
      'provider_inspection_directorate': 'text',
      'provider_main_phone_number': 'text',
      'provider_website': 'text',
      'provider_onspd_icb_code': 'text',
      'provider_onspd_icb_name': 'text',
      'provider_inspection_areas': 'jsonb',

      // Timestamps
      'updated_at': 'timestamptz',
      'last_seen_at': 'timestamptz'
    };

    async function checkSchema() {
      const output = document.getElementById('output');
      output.innerHTML = '<pre>Checking database schema...</pre>';

      try {
        // Get column information from the database
        const { data, error } = await supabase
          .from('CQC All GPs')
          .select('*')
          .limit(0);

        if (error) {
          output.innerHTML = `<pre class="error">Error accessing table: ${error.message}</pre>`;
          return;
        }

        // Query the schema using SQL
        const { data: columns, error: schemaError } = await supabase.rpc('get_table_columns', {
          table_name: 'CQC All GPs'
        }).catch(() => ({ data: null, error: 'RPC not available' }));

        // Fallback: try to get a sample row to see what columns exist
        const { data: sampleRow, error: sampleError } = await supabase
          .from('CQC All GPs')
          .select('*')
          .limit(1)
          .single();

        let existingColumns = [];
        if (sampleRow) {
          existingColumns = Object.keys(sampleRow);
        }

        let report = 'DATABASE SCHEMA CHECK REPORT\n';
        report += '=============================\n\n';

        const missingColumns = [];
        const presentColumns = [];

        for (const [column, type] of Object.entries(requiredColumns)) {
          if (existingColumns.includes(column)) {
            presentColumns.push(column);
          } else {
            missingColumns.push({ column, type });
          }
        }

        report += `‚úÖ PRESENT COLUMNS (${presentColumns.length}):\n`;
        presentColumns.forEach(col => {
          report += `   - ${col}\n`;
        });

        report += `\n‚ùå MISSING COLUMNS (${missingColumns.length}):\n`;
        missingColumns.forEach(({ column, type }) => {
          report += `   - ${column} (${type})\n`;
        });

        report += '\nüìä SUMMARY:\n';
        report += `   Total required columns: ${Object.keys(requiredColumns).length}\n`;
        report += `   Present: ${presentColumns.length}\n`;
        report += `   Missing: ${missingColumns.length}\n`;
        report += `   Completion: ${Math.round(presentColumns.length / Object.keys(requiredColumns).length * 100)}%\n`;

        if (missingColumns.length > 0) {
          report += '\n‚ö†Ô∏è ACTION REQUIRED:\n';
          report += '   Click "Generate Missing Columns SQL" to create the migration script\n';
        } else {
          report += '\n‚úÖ All required columns are present!\n';
        }

        output.innerHTML = `<pre class="${missingColumns.length > 0 ? 'warning' : 'success'}">${report}</pre>`;

        // Store for migration generation
        window.missingColumns = missingColumns;

      } catch (err) {
        output.innerHTML = `<pre class="error">Error: ${err.message}</pre>`;
      }
    }

    async function checkEdgeFunctions() {
      const output = document.getElementById('output');
      output.innerHTML = '<pre>Checking edge functions...</pre>';

      try {
        // Test fetch-nhs-data-complete
        const testPayload = {
          location_id: 'test-check',
          data_sources: []
        };

        const { data, error } = await supabase.functions.invoke('fetch-nhs-data-complete', {
          body: testPayload
        });

        let report = 'EDGE FUNCTION CHECK\n';
        report += '===================\n\n';

        if (error) {
          if (error.message?.includes('not found')) {
            report += '‚ùå fetch-nhs-data-complete: NOT DEPLOYED\n';
            report += '   Run: supabase functions deploy fetch-nhs-data-complete\n';
          } else {
            report += '‚ö†Ô∏è fetch-nhs-data-complete: ERROR\n';
            report += `   ${error.message}\n`;
          }
        } else {
          report += '‚úÖ fetch-nhs-data-complete: DEPLOYED AND RESPONDING\n';
          if (data) {
            report += `   Response status: ${data.status || 'unknown'}\n`;
          }
        }

        // Test fetch-cqc-details
        const { data: cqcData, error: cqcError } = await supabase.functions.invoke('fetch-cqc-details', {
          body: { location_id: 'test' }
        });

        report += '\n';
        if (cqcError) {
          if (cqcError.message?.includes('not found')) {
            report += '‚ùå fetch-cqc-details: NOT DEPLOYED\n';
          } else {
            report += '‚úÖ fetch-cqc-details: DEPLOYED (legacy, not needed)\n';
          }
        } else {
          report += '‚úÖ fetch-cqc-details: DEPLOYED (legacy, not needed)\n';
        }

        output.innerHTML = `<pre class="${error && error.message?.includes('not found') ? 'error' : 'success'}">${report}</pre>`;

      } catch (err) {
        output.innerHTML = `<pre class="error">Error: ${err.message}</pre>`;
      }
    }

    function generateMigration() {
      const output = document.getElementById('output');

      if (!window.missingColumns || window.missingColumns.length === 0) {
        output.innerHTML = '<pre class="warning">Run "Check Database Schema" first to identify missing columns</pre>';
        return;
      }

      let sql = '-- Migration script to add missing columns to CQC All GPs table\n';
      sql += '-- Generated: ' + new Date().toISOString() + '\n\n';

      sql += '-- Add missing columns\n';
      window.missingColumns.forEach(({ column, type }) => {
        const pgType = type.replace('integer', 'int').replace('timestamptz', 'timestamp with time zone');
        sql += `ALTER TABLE "CQC All GPs" ADD COLUMN IF NOT EXISTS "${column}" ${pgType};\n`;
      });

      sql += '\n-- Create index on ods_code for faster lookups\n';
      sql += 'CREATE INDEX IF NOT EXISTS idx_cqc_all_gps_ods_code ON "CQC All GPs" (ods_code);\n';

      sql += '\n-- Create index on location_id\n';
      sql += 'CREATE INDEX IF NOT EXISTS idx_cqc_all_gps_location_id ON "CQC All GPs" (location_id);\n';

      sql += '\n-- Update trigger for updated_at\n';
      sql += `CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_cqc_all_gps_updated_at
BEFORE UPDATE ON "CQC All GPs"
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();\n`;

      output.innerHTML = '<pre class="success">COPY AND RUN THIS SQL IN SUPABASE SQL EDITOR:\n\n' + sql + '</pre>';

      // Also copy to clipboard
      if (navigator.clipboard) {
        navigator.clipboard.writeText(sql).then(() => {
          output.innerHTML += '<pre class="success">\n‚úÖ SQL copied to clipboard!</pre>';
        });
      }
    }

    // Auto-check on load
    window.onload = () => {
      checkSchema();
    };
  </script>
</body>
</html>
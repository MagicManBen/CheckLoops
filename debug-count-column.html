<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Count Column Debug</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        .result {
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
        }
        .success { background-color: #d4edda; }
        .error { background-color: #f8d7da; }
    </style>
</head>
<body>
    <h1>CSV Count Column Debug</h1>
    <p>This page analyzes why the Count column isn't being uploaded correctly.</p>
    
    <div>
        <h2>Upload your CSV file</h2>
        <input type="file" id="csvFile" accept=".csv">
    </div>
    
    <div id="results"></div>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
    <script>
        document.getElementById('csvFile').addEventListener('change', handleFileSelect);
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<p>Analyzing file...</p>';
            
            Papa.parse(file, {
                header: true,
                dynamicTyping: false,
                skipEmptyLines: true,
                complete: function(results) {
                    analyzeCSV(results);
                }
            });
        }
        
        function analyzeCSV(results) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';
            
            // Get the raw headers
            const rawHeaders = Array.isArray(results.meta?.fields) ? results.meta.fields : Object.keys(results.data[0] || {});
            
            // 1. Display raw headers
            let headersHtml = '<h3>Raw CSV Headers</h3>';
            headersHtml += '<table><tr><th>Index</th><th>Header</th><th>Is Empty?</th></tr>';
            
            rawHeaders.forEach((header, index) => {
                const isEmpty = !header || header.trim() === '';
                headersHtml += `<tr>
                    <td>${index}</td>
                    <td>${isEmpty ? '<em>[empty]</em>' : header}</td>
                    <td>${isEmpty ? 'Yes' : 'No'}</td>
                </tr>`;
            });
            headersHtml += '</table>';
            
            // 2. Find last empty header
            let lastEmptyIdx = -1;
            for (let i = rawHeaders.length - 1; i >= 0; i--) {
                const h = rawHeaders[i];
                if (!h || String(h).trim() === '') {
                    lastEmptyIdx = i;
                    break;
                }
            }
            
            // 3. Create clean headers (rename last empty to "Count")
            const cleanedHeaders = [];
            for (let i = 0; i < rawHeaders.length; i++) {
                const h = rawHeaders[i];
                if (!h || String(h).trim() === '') {
                    if (i === lastEmptyIdx) {
                        cleanedHeaders.push('Count');
                    } else {
                        // drop other empty headers
                        continue;
                    }
                } else {
                    cleanedHeaders.push(h);
                }
            }
            
            // 4. Display cleaned headers
            let cleanedHtml = '<h3>Cleaned Headers (Last Empty → "Count")</h3>';
            cleanedHtml += '<table><tr><th>Index</th><th>Header</th></tr>';
            
            cleanedHeaders.forEach((header, index) => {
                cleanedHtml += `<tr>
                    <td>${index}</td>
                    <td>${header}</td>
                </tr>`;
            });
            cleanedHtml += '</table>';
            
            // 5. Show sample data with Count values
            let samplesHtml = '<h3>Sample Data (First 5 Rows)</h3>';
            samplesHtml += '<table><tr>';
            
            // Create header row
            cleanedHeaders.forEach(header => {
                samplesHtml += `<th>${header}</th>`;
            });
            samplesHtml += '</tr>';
            
            // Process data rows
            const processedRows = results.data.slice(0, 5).map(row => {
                const processed = {};
                for (let i = 0, j = 0; i < rawHeaders.length; i++) {
                    const originalHeader = rawHeaders[i];
                    const isEmpty = !originalHeader || String(originalHeader).trim() === '';
                    
                    // If this is an empty header but not the last one, skip it
                    if (isEmpty && i !== lastEmptyIdx) continue;
                    
                    // Use "Count" for last empty header, otherwise original header
                    const key = (isEmpty && i === lastEmptyIdx) ? 'Count' : originalHeader;
                    processed[key] = row[originalHeader];
                    j++;
                }
                return processed;
            });
            
            // Add data rows
            processedRows.forEach(row => {
                samplesHtml += '<tr>';
                cleanedHeaders.forEach(header => {
                    const value = row[header] || '';
                    samplesHtml += `<td>${value}</td>`;
                });
                samplesHtml += '</tr>';
            });
            samplesHtml += '</table>';
            
            // 6. Display records that would be sent to Supabase
            let uploadHtml = '<h3>Records To Upload (First 3)</h3>';
            
            const headerToDb = {
                "Full Name of the Session Holder of the Session": "full_name_session_holder",
                "Day of Week": "day_of_week",
                "Session's Session Start": "session_start",
                "Session's Session End": "session_end",
                "Appointment Date": "appointment_date",
                "Appointment Time": "appointment_time",
                "Slot Type": "slot_type",
                "Slot Duration": "slot_duration",
                "Availability": "availability",
                "DNA": "dna_status",
                "Booked Time to Slot Time": "booked_time_to_slot_time",
                "Arrive Time to Send In Time": "arrive_time_to_send_in_time",
                "Slot Time to Send In Time": "slot_time_to_send_in_time",
                "Slot Time to Arrive Time": "slot_time_to_arrive_time",
                "Consultation Time": "consultation_time",
                "Count": "Count"
            };
            
            const records = processedRows.map((row, idx) => {
                const obj = {};
                for (const key in row) {
                    if (Object.prototype.hasOwnProperty.call(headerToDb, key)) {
                        const dbKey = headerToDb[key];
                        let val = row[key];
                        if (typeof val === 'string') {
                            val = val.trim();
                        }
                        obj[dbKey] = val;
                    }
                }
                obj.site_id = 2;
                obj.csv_row_number = idx + 1;
                return obj;
            });
            
            uploadHtml += '<pre>' + JSON.stringify(records, null, 2) + '</pre>';
            
            // 7. Analysis of what might be happening
            let analysisHtml = '<div class="result ';
            
            // Check if Count is present in processed data
            const countPresent = processedRows.some(row => row.Count !== undefined && row.Count !== '');
            
            if (countPresent) {
                analysisHtml += 'success"><h3>✅ Success: Count Column is Processed Correctly!</h3>';
                analysisHtml += '<p>The CSV parser is correctly identifying the last empty header as "Count" and the values are present.</p>';
            } else {
                analysisHtml += 'error"><h3>❌ Error: Count Values Missing</h3>';
                analysisHtml += '<p>The CSV may not have a proper empty header column at the end or values are not being read.</p>';
            }
            
            // Check if Count would be uploaded properly
            const countUploaded = records.some(record => record.Count !== undefined && record.Count !== '');
            
            if (countUploaded) {
                analysisHtml += '<p>✅ The upload process would include Count values.</p>';
            } else {
                analysisHtml += '<p>❌ The upload process would NOT include Count values.</p>';
            }
            
            // Add recommendations
            analysisHtml += '<h3>Recommendations:</h3><ul>';
            if (!countPresent) {
                analysisHtml += '<li>Check if your CSV actually has an empty header column as the second-to-last column</li>';
                analysisHtml += '<li>Make sure there are values in the last column</li>';
            }
            analysisHtml += '<li>Verify that the last column in your CSV is formatted properly</li>';
            analysisHtml += '<li>Try re-uploading a CSV with corrected headers (ensure there\'s an empty header for Count)</li>';
            analysisHtml += '</ul></div>';
            
            // Add all HTML to results
            resultsDiv.innerHTML = headersHtml + cleanedHtml + samplesHtml + uploadHtml + analysisHtml;
        }
    </script>
</body>
</html>
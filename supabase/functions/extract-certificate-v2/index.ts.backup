import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import OpenAI from "npm:openai@^4.57.0"
import * as pdfParse from "https://deno.land/x/pdf_parse@v1.1.1/mod.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Get the authorization header
    const authHeader = req.headers.get('Authorization')
    console.log('[DEBUG] Auth header present:', !!authHeader)

    if (!authHeader) {
      return json({ success: false, error: 'Unauthorized - No auth header' }, 401)
    }

    // Verify user with Supabase
    const supabaseUrl = Deno.env.get('SUPABASE_URL')
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')

    console.log('[DEBUG] Environment check - SUPABASE_URL:', !!supabaseUrl)

    if (supabaseUrl && supabaseServiceKey) {
      console.log('[DEBUG] Using production authentication')
      const supabaseClient = createClient(
        supabaseUrl,
        supabaseServiceKey,
        { auth: { persistSession: false } }
      )

      const token = authHeader.replace('Bearer ', '')
      const { data: { user }, error: userError } = await supabaseClient.auth.getUser(token)

      console.log('[DEBUG] User verification - user:', !!user, 'error:', !!userError)

      if (userError || !user) {
        return json({ success: false, error: `Unauthorized - ${userError?.message || 'No user'}` }, 401)
      }
    } else {
      console.log('[DEBUG] Missing Supabase credentials, skipping auth')
    }

    // Get request body
    const { text, signedUrl, fileUrl } = await req.json()
    let contentText = (text ?? "").toString().trim()

    console.log('[DEBUG] Request data - text length:', contentText.length, 'signedUrl:', !!signedUrl, 'fileUrl:', !!fileUrl)

    // If no text provided but we have a URL, fetch and process the file
    if (!contentText && (signedUrl || fileUrl)) {
      const urlToFetch = signedUrl || fileUrl
      console.log('[DEBUG] Fetching file from URL for processing')

      try {
        const fileResponse = await fetch(urlToFetch)
        if (!fileResponse.ok) {
          throw new Error(`Failed to fetch file: ${fileResponse.status}`)
        }

        const contentType = fileResponse.headers.get('content-type') || ''
        const arrayBuffer = await fileResponse.arrayBuffer()

        console.log('[DEBUG] File fetched - content type:', contentType, 'size:', arrayBuffer.byteLength)

        // Process based on content type
        if (contentType.includes('pdf')) {
          console.log('[DEBUG] Processing PDF file')
          try {
            // Convert ArrayBuffer to Uint8Array for pdf-parse
            const uint8Array = new Uint8Array(arrayBuffer)
            const pdfData = await pdfParse.default(uint8Array)
            contentText = pdfData.text || ''
            console.log('[DEBUG] PDF text extracted:', contentText.length, 'characters')
          } catch (pdfError) {
            console.error('[DEBUG] PDF parsing error:', pdfError)
            // Fallback: treat as binary and let AI try to process
            contentText = `[PDF file - binary content, please extract any visible text patterns]`
          }
        } else if (contentType.includes('image')) {
          console.log('[DEBUG] Processing image file - will use AI vision')
          // For images, we'll pass them directly to GPT-4 Vision
          // Convert to base64 for GPT-4 Vision
          const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)))
          contentText = `[IMAGE:${base64}]`
        } else {
          console.log('[DEBUG] Unknown file type, attempting text extraction')
          // Try to read as text
          contentText = new TextDecoder().decode(arrayBuffer)
        }
      } catch (fetchError: any) {
        console.error('[DEBUG] File fetch/process error:', fetchError)
        return json({ success: false, error: `Failed to process file: ${fetchError.message}` }, 400)
      }
    }

    if (!contentText || contentText.length < 5) {
      return json({ success: false, error: "No content to process" }, 400)
    }

    // Get OpenAI API key from environment
    const openaiApiKey = Deno.env.get('OPENAI_API_KEY') || Deno.env.get('CheckLoopsAI')
    if (!openaiApiKey) {
      console.error('[DEBUG] No OpenAI API key configured')
      return json({ success: false, error: 'OpenAI API key not configured' }, 500)
    }

    console.log('[DEBUG] Extracting certificate details from content length:', contentText.length)

    // Initialize OpenAI client
    const openai = new OpenAI({ apiKey: openaiApiKey })

    // Handle image content with GPT-4 Vision
    let messages: any[] = []
    if (contentText.startsWith('[IMAGE:')) {
      const base64Image = contentText.substring(7, contentText.length - 1)
      console.log('[DEBUG] Using GPT-4 Vision for image processing')

      messages = [
        {
          role: "system",
          content: `You are a training certificate analysis expert. Extract information from the certificate image and return STRICT JSON only.

REQUIRED JSON KEYS:
- person_name: The name of the person who completed the training
- training_name: The name of the training/course
- completion_date: The date when training was completed (YYYY-MM-DD format)
- expiry_date: The expiry date if available (YYYY-MM-DD format or null)
- provider: The training provider/organization
- certificate_id: Certificate ID/reference number or null
- additional_details: Any other relevant details

Return only valid JSON.`
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: "Extract the certificate information from this image:"
            },
            {
              type: "image_url",
              image_url: {
                url: `data:image/jpeg;base64,${base64Image}`
              }
            }
          ]
        }
      ]
    } else {
      // Text-based extraction
      messages = [
        {
          role: "system",
          content: `You are a training certificate analysis expert. Extract information from the certificate text and return STRICT JSON only.

REQUIRED JSON KEYS:
- person_name: The name of the person who completed the training
- training_name: The name of the training/course
- completion_date: The date when training was completed (YYYY-MM-DD format)
- expiry_date: The expiry date if available (YYYY-MM-DD format or null)
- provider: The training provider/organization
- certificate_id: Certificate ID/reference number or null
- additional_details: Any other relevant details

Important:
1. Look for dates in any format and convert to YYYY-MM-DD
2. Common date formats: "26Sep2025", "26/09/2025", "September 26, 2025", etc.
3. If you see a filename like "43630_Certificate_26Sep2025102910.pdf", extract the date
4. Return only valid JSON with no extra text`
        },
        {
          role: "user",
          content: `Extract certificate information from this text:\n\n${contentText}`
        }
      ]
    }

    // Call OpenAI API
    const model = contentText.startsWith('[IMAGE:') ? "gpt-4o" : "gpt-4o-mini"
    console.log('[DEBUG] Using model:', model)

    const completion = await openai.chat.completions.create({
      model: model,
      messages: messages,
      temperature: 0,
      max_tokens: 1000,
      response_format: model === "gpt-4o-mini" ? { type: "json_object" } : undefined
    })

    const rawResponse = completion.choices?.[0]?.message?.content ?? "{}"
    console.log('[DEBUG] AI response received:', rawResponse.substring(0, 200))

    const data = parseJSON(rawResponse)

    // Ensure date formats are correct
    if (data?.completion_date) {
      data.completion_date = formatDateToISO(data.completion_date)
    }

    if (data?.expiry_date) {
      data.expiry_date = formatDateToISO(data.expiry_date)
    }

    console.log('[DEBUG] Certificate details extracted successfully:', JSON.stringify(data))

    return json({ success: true, data })

  } catch (error: any) {
    console.error('[DEBUG] Edge function error:', error)
    return json({
      success: false,
      error: String(error?.message ?? error)
    }, 400)
  }
})

function json(body: unknown, status = 200) {
  return new Response(JSON.stringify(body), {
    status,
    headers: {
      ...corsHeaders,
      "Content-Type": "application/json"
    }
  })
}

function parseJSON(str: string): any {
  try {
    // Try to extract JSON from code blocks if present
    const match = str.match(/```(?:json)?\s*([\s\S]*?)\s*```/i)
    const body = match ? match[1] : str
    return JSON.parse(body)
  } catch {
    // Return default structure if parsing fails
    return {
      person_name: null,
      training_name: null,
      completion_date: null,
      expiry_date: null,
      provider: null,
      certificate_id: null,
      additional_details: null
    }
  }
}

function formatDateToISO(dateStr: string): string | null {
  if (!dateStr || dateStr === 'null' || dateStr === 'undefined') return null

  try {
    // Already in correct format?
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
      return dateStr
    }

    // Handle format like "26Sep2025"
    const formatMatch = dateStr.match(/(\d{1,2})([A-Za-z]{3})(\d{4})/i)
    if (formatMatch) {
      const day = formatMatch[1].padStart(2, '0')
      const monthStr = formatMatch[2]
      const year = formatMatch[3]

      const months: {[key: string]: string} = {
        'jan': '01', 'feb': '02', 'mar': '03', 'apr': '04',
        'may': '05', 'jun': '06', 'jul': '07', 'aug': '08',
        'sep': '09', 'oct': '10', 'nov': '11', 'dec': '12'
      }

      const month = months[monthStr.toLowerCase()]
      if (month) {
        return `${year}-${month}-${day}`
      }
    }

    // Handle format like "26/09/2025" or "09/26/2025"
    const slashMatch = dateStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/)
    if (slashMatch) {
      const part1 = parseInt(slashMatch[1])
      const part2 = parseInt(slashMatch[2])
      const year = slashMatch[3]

      // Guess format based on values (US vs UK)
      if (part1 > 12) {
        // Must be DD/MM/YYYY
        return `${year}-${slashMatch[2].padStart(2, '0')}-${slashMatch[1].padStart(2, '0')}`
      } else if (part2 > 12) {
        // Must be MM/DD/YYYY
        return `${year}-${slashMatch[1].padStart(2, '0')}-${slashMatch[2].padStart(2, '0')}`
      } else {
        // Assume UK format DD/MM/YYYY for ambiguous dates
        return `${year}-${slashMatch[2].padStart(2, '0')}-${slashMatch[1].padStart(2, '0')}`
      }
    }

    // Try standard Date parsing as fallback
    const date = new Date(dateStr)
    if (!isNaN(date.getTime())) {
      return date.toISOString().split('T')[0]
    }

    return null
  } catch {
    return null
  }
}
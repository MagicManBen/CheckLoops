import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import OpenAI from "npm:openai@^4.57.0"
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.0"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': '*',
  'Access-Control-Allow-Methods': '*',
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const { signedUrl, filename } = await req.json()
    console.log('Processing:', filename)

    if (!signedUrl) {
      throw new Error('No URL provided')
    }

    // Initialize Supabase client to get training types
    const supabaseUrl = Deno.env.get('SUPABASE_URL')
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
    
    if (!supabaseUrl || !supabaseKey) {
      throw new Error('Supabase credentials missing')
    }

    const supabase = createClient(supabaseUrl, supabaseKey)

    // Fetch available training types
    const { data: trainingTypes, error: trainingError } = await supabase
      .from('training_types')
      .select('name')
      .eq('active', true)
      .order('name')

    if (trainingError) {
      console.error('Training types fetch error:', trainingError)
      throw new Error('Failed to fetch training types')
    }

    const availableTypes = trainingTypes?.map(t => t.name) || []
    console.log('Available training types:', availableTypes)

    // Download file to validate
    const fileResponse = await fetch(signedUrl)
    if (!fileResponse.ok) {
      throw new Error('Download failed: ' + fileResponse.status)
    }

    const arrayBuffer = await fileResponse.arrayBuffer()
    const contentType = fileResponse.headers.get('content-type') || ''
    
    // Ensure it's an image
    const isImage = contentType.includes('image') || filename?.toLowerCase().match(/\.(png|jpg|jpeg|gif|webp)$/i)
    if (!isImage) {
      throw new Error('Only image files supported')
    }

    // Get API key
    const openaiKey = Deno.env.get('OPENAI_API_KEY') || Deno.env.get('CheckLoopsAI')
    if (!openaiKey) {
      throw new Error('API key missing')
    }

    console.log('Calling OpenAI with direct URL')
    console.log('URL preview:', signedUrl.substring(0, 100))
    
    const openai = new OpenAI({ apiKey: openaiKey })

    const availableTypesText = availableTypes.length > 0 
      ? 'Available training types: ' + availableTypes.join(', ')
      : 'No available training types found'

    const promptText = 'Extract certificate info in this format:\nPERSON_NAME: [name]\nTRAINING_NAME: [course name - MUST exactly match one of these options: ' + availableTypes.join(', ') + ' - if no exact match found, return "NO_MATCH_FOUND"]\nCOMPLETION_DATE: [YYYY-MM-DD]\nEXPIRY_DATE: [YYYY-MM-DD or N/A]\nTRAINING_PROVIDER: [organization]\nCERTIFICATE_NUMBER: [number or N/A]\n\n' + availableTypesText + '\n\nIMPORTANT: For TRAINING_NAME, you MUST select exactly one of the listed training types. If the certificate training does not closely match any of these options, return "NO_MATCH_FOUND" instead of guessing.'

    const requestPayload = {
      model: "gpt-4o-mini",
      messages: [
        {
          role: "user",
          content: [
            {
              type: "text",
              text: promptText
            },
            {
              type: "image_url",
              image_url: { url: signedUrl }
            }
          ]
        }
      ],
      temperature: 0,
      max_tokens: 400
    }

    console.log('REQUEST:', JSON.stringify(requestPayload, null, 2))
    
    const completion = await openai.chat.completions.create(requestPayload)

    console.log('RESPONSE:', JSON.stringify(completion, null, 2))
    
    const aiText = completion.choices[0].message.content || ""
    console.log('AI TEXT:', aiText)

    // Parse response
    const parseField = (text: string, field: string) => {
      const regex = new RegExp(field + ':\\s*(.+)', 'i')
      const match = text.match(regex)
      const value = match ? match[1].trim() : 'PARSE_FAILED'
      console.log(field + ': "' + value + '"')
      return value
    }

    const trainingName = parseField(aiText, 'TRAINING_NAME')
    const isValidTraining = availableTypes.includes(trainingName)
    
    console.log('Training name extracted:', trainingName)
    console.log('Is valid training type:', isValidTraining)
    console.log('Available types:', availableTypes)

    const data = {
      person_name: parseField(aiText, 'PERSON_NAME'),
      training_name: trainingName,
      training_name_valid: isValidTraining,
      completion_date: parseField(aiText, 'COMPLETION_DATE'),
      expiry_date: parseField(aiText, 'EXPIRY_DATE'),
      provider: parseField(aiText, 'TRAINING_PROVIDER'),
      certificate_id: parseField(aiText, 'CERTIFICATE_NUMBER')
    }

    console.log('EXTRACTED:', JSON.stringify(data, null, 2))

    return new Response(JSON.stringify({
      success: true,
      raw_text: aiText,
      data: data,
      available_training_types: availableTypes,
      training_match_status: {
        extracted_name: trainingName,
        is_valid: isValidTraining,
        message: isValidTraining 
          ? 'Training type matches available options' 
          : trainingName === 'NO_MATCH_FOUND'
            ? 'AI could not match training to available options'
            : 'Training type does not match any available options'
      },
      debug: {
        model: 'gpt-4o-mini',
        approach: 'Direct URL with Training Type Matching',
        fileSize: Math.round(arrayBuffer.byteLength / 1024) + ' KB',
        available_types_count: availableTypes.length
      }
    }), { headers: { ...corsHeaders, 'Content-Type': 'application/json' } })

  } catch (error: any) {
    console.error('ERROR:', error.message)
    return new Response(JSON.stringify({
      success: false,
      error: error.message
    }), { 
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500 
    })
  }
})

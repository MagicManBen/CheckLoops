// UNO R4 WiFi (BLE Central) + Eyoyo EY-015P
// Goal: When you scan a QR code, the decoded text appears as lines in Serial Monitor.
// Board: Arduino UNO R4 WiFi (BLE only via ESP32-S3 connectivity module)
// Scanner: Put Eyoyo in **BLE** mode and enable **Enter** suffix (or CR/LF) so each scan ends cleanly.

#include <Arduino.h>
#include <ArduinoBLE.h>

// ---- Tuning ----
static const unsigned long SCAN_WINDOW_MS = 8000; // rescan interval
static const size_t MAX_LINE = 256;

// Optional: If your Eyoyo advertises a name, set a prefix to filter
static const char *NAME_HINT_PREFIX = "EY-"; // match names like EY-015P-82823

// HID UUIDs
static const char *UUID_HID_SERVICE   = "1812"; // Human Interface Device service
static const char *UUID_BOOT_KBD_IN   = "2A22"; // Boot Keyboard Input Report
static const char *UUID_HID_REPORT    = "2A4D"; // HID Report (generic)
static const char *UUID_HID_PROTOCOL  = "2A4E"; // Protocol Mode (0=Boot, 1=Report)

// Vendor (Eyoyo-like) UART services seen on similar models
static const char *UUID_VENDOR_SVC_1 = "FFF0"; // common
static const char *UUID_VENDOR_CH_1  = "FFF1"; // notify/ASCII
static const char *UUID_VENDOR_SVC_2 = "FFE0"; // alternate (HM-10 style)
static const char *UUID_VENDOR_CH_2  = "FFE1";
static const bool  PREFER_VENDOR_FIRST = true; // try vendor UART before HID

BLEDevice        dev;
BLEService       hidSvc;
BLECharacteristic bootKbdIn;
BLECharacteristic hidReportChars[8];
int              hidReportCount = 0;

// Fallback for vendor/ASCII characteristic
BLECharacteristic asciiFallback;

// Line buffer for decoded output
static char lineBuf[MAX_LINE];
static size_t lineLen = 0;

// Track previous HID keys to avoid repeats
static uint8_t prevKeys[6] = {0};

// ----------------- HID decode helpers -----------------
static char decodeHIDKey(uint8_t key, bool shift) {
  // US keyboard map for common barcode symbols. Extend as needed.
  if (key >= 0x04 && key <= 0x1D) { // a-z
    char c = 'a' + (key - 0x04);
    return shift ? (char)toupper(c) : c;
  }
  if (key >= 0x1E && key <= 0x27) { // 1-9,0
    const char normal[] = {'1','2','3','4','5','6','7','8','9','0'};
    const char shifted[] = {'!','@','#','$','%','^','&','*','(',')'};
    return shift ? shifted[key - 0x1E] : normal[key - 0x1E];
  }
  switch (key) {
    case 0x28: return '\n'; // Enter
    case 0x2C: return ' ';
    case 0x2D: return shift ? '_' : '-';
    case 0x2E: return shift ? '+' : '=';
    case 0x2F: return shift ? '{' : '[';
    case 0x30: return shift ? '}' : ']';
    case 0x31: return shift ? '|' : '\\';
    case 0x33: return shift ? '"' : '\'';
    case 0x34: return shift ? '~' : '`';
    case 0x35: return shift ? ':' : ';';
    case 0x36: return shift ? '<' : ',';
    case 0x37: return shift ? '>' : '.';
    case 0x38: return shift ? '?' : '/';
    default:   return 0; // unhandled
  }
}

static void flushLine() {
  if (lineLen > 0) {
    lineBuf[lineLen] = '\0';
    Serial.print(F("SCAN: "));
    Serial.println(lineBuf);
    lineLen = 0;
  }
}

static void appendChar(char c) {
  if (c == '\n') { flushLine(); return; }
  if (lineLen < MAX_LINE - 1) {
    lineBuf[lineLen++] = c;
  }
}

static void handleBootKeyboardReport(const uint8_t *r, int n) {
  if (n < 8) return; // boot report is 8 bytes
  uint8_t mods = r[0];
  bool shift = (mods & 0x22) || (mods & 0x02) || (mods & 0x20); // either L/R shift bit

  // r[2..7] up to 6 keys currently pressed
  for (int i = 2; i < 8; i++) {
    uint8_t k = r[i];
    if (!k) continue;
    bool already = false;
    for (uint8_t pk : prevKeys) if (pk == k) { already = true; break; }
    if (already) continue; // skip repeats from same frame

    char out = decodeHIDKey(k, shift);
    if (out) appendChar(out);
  }
  // store for de-dup within next frame
  memcpy(prevKeys, r + 2, 6);
}

static void handleAsciiBytes(const uint8_t *buf, int n) {
  for (int i = 0; i < n; i++) {
    uint8_t b = buf[i];
    if (b == '\r') continue; // ignore CR
    if (b == '\n') { flushLine(); continue; }
    if (b >= 32 && b < 127) appendChar((char)b);
  }
}

static bool subscribeIfNotifiable(BLECharacteristic &c) {
  if (c && c.canSubscribe()) return c.subscribe();
  return false;
}

// ---- UUID helpers (match 16-bit UUIDs even when presented as 128-bit) ----
static bool uuidMatches16(const String &u, const char *short16) {
  String U = u; U.toLowerCase();
  String s16 = String(short16); s16.toLowerCase();
  if (U == s16) return true; // "2a4d"
  if (U.endsWith(s16)) return true; // "00002a4d-0000-1000-8000-00805f9b34fb"
  String full = "0000" + s16 + "-0000-1000-8000-00805f9b34fb";
  return U == full;
}

static BLEService findServiceBy16(const char *short16) {
  for (int si = 0; si < dev.serviceCount(); si++) {
    BLEService s = dev.service(si);
    if (uuidMatches16(s.uuid(), short16)) return s;
  }
  return BLEService();
}

static BLECharacteristic findCharBy16(BLEService &s, const char *short16) {
  for (int ci = 0; ci < s.characteristicCount(); ci++) {
    BLECharacteristic c = s.characteristic(ci);
    if (uuidMatches16(c.uuid(), short16)) return c;
  }
  return BLECharacteristic();
}

// ---- Debug: dump all services/chars ----
static void dumpGatt() {
  Serial.println(F("-- GATT inventory --"));
  for (int si = 0; si < dev.serviceCount(); si++) {
    BLEService s = dev.service(si);
    Serial.print(F("svc ")); Serial.println(s.uuid());
    for (int ci = 0; ci < s.characteristicCount(); ci++) {
      BLECharacteristic c = s.characteristic(ci);
      Serial.print(F("  ch  ")); Serial.print(c.uuid());
      Serial.print(F(" props:"));
      Serial.print(c.canRead()?"R":"-");
      Serial.print(c.canWrite()?"W":"-");
      Serial.print(c.canSubscribe()?"N":"-");
      Serial.println();
    }
  }
}

static bool discoverAndSubscribe() {
  Serial.println(F("Discovering attributes..."));
  if (!dev.discoverAttributes()) {
    Serial.println(F("discoverAttributes FAILED"));
    return false;
  }
  dumpGatt();

  // Try Eyoyo vendor UART first (FFF0/FFF1, fallback FFE0/FFE1)
  if (PREFER_VENDOR_FIRST) {
    BLEService vs;
    // find service by 16-bit match
    for (int si = 0; si < dev.serviceCount(); si++) {
      BLEService s = dev.service(si);
      if (uuidMatches16(s.uuid(), UUID_VENDOR_SVC_1) || uuidMatches16(s.uuid(), UUID_VENDOR_SVC_2)) {
        vs = s; break;
      }
    }
    if (vs) {
      BLECharacteristic vc;
      for (int ci = 0; ci < vs.characteristicCount(); ci++) {
        BLECharacteristic c = vs.characteristic(ci);
        if (uuidMatches16(c.uuid(), UUID_VENDOR_CH_1) || uuidMatches16(c.uuid(), UUID_VENDOR_CH_2)) {
          vc = c; break;
        }
      }
      if (vc && subscribeIfNotifiable(vc)) {
        asciiFallback = vc;
        Serial.print(F("Vendor UART subscribed on ")); Serial.print(vs.uuid()); Serial.print(F("/")); Serial.println(vc.uuid());
        // Early return: we have our ASCII pipe
        return true;
      }
    }
  }

  // Try HID first
  hidSvc = findServiceBy16(UUID_HID_SERVICE);
  if (hidSvc) {
    Serial.println(F("HID service found (0x1812)"));
    // Set HID Protocol Mode to Boot (0x00) so Boot Keyboard Input (2A22) will notify
    BLECharacteristic proto = hidSvc.characteristic(UUID_HID_PROTOCOL);
    if (proto && proto.canWrite()) {
      uint8_t v = 0x00; // Boot
      if (proto.writeValue(&v, 1)) {
        Serial.println(F("Set HID Protocol Mode = Boot"));
      } else {
        Serial.println(F("Failed to set HID Protocol Mode (continuing in Report mode)"));
      }
    }
    bootKbdIn = findCharBy16(hidSvc, UUID_BOOT_KBD_IN);
    if (bootKbdIn) {
      Serial.println(F("Boot Keyboard Input (0x2A22) found"));
      subscribeIfNotifiable(bootKbdIn);
    }
    // collect up to a few HID Report chars
    hidReportCount = 0;
    for (int i = 0; i < hidSvc.characteristicCount() && hidReportCount < 8; i++) {
      BLECharacteristic c = hidSvc.characteristic(i);
      if (uuidMatches16(c.uuid(), UUID_HID_REPORT)) {
        if (subscribeIfNotifiable(c)) {
          hidReportChars[hidReportCount++] = c;
        }
      }
    }
  }

  if (!hidSvc) {
    Serial.println(F("Note: HID service not visible. Many scanners hide HID until encrypted/paird."));
    Serial.println(F("Try switching the Eyoyo to BLE 'simple/transparent' (no pairing) mode via its setup barcode."));
  }

  // Fallback: subscribe to the first notifiable char anywhere
  if (!bootKbdIn && hidReportCount == 0) {
    for (int si = 0; si < dev.serviceCount(); si++) {
      BLEService s = dev.service(si);
      for (int ci = 0; ci < s.characteristicCount(); ci++) {
        BLECharacteristic c = s.characteristic(ci);
        if (subscribeIfNotifiable(c)) {
          asciiFallback = c;
          Serial.print(F("Fallback subscribed ")); Serial.print(s.uuid()); Serial.print(F("/")); Serial.println(c.uuid());
          break;
        }
      }
      if (asciiFallback) break;
    }
  }

  Serial.print(F("Subscribed: bootKbdIn=")); Serial.print(bootKbdIn ? 1 : 0);
  Serial.print(F(" reports=")); Serial.print(hidReportCount);
  Serial.print(F(" asciiFallback=")); Serial.println(asciiFallback ? 1 : 0);
  return bootKbdIn || hidReportCount > 0 || asciiFallback;
}

static bool connectToEyoyo() {
  Serial.println(F("Scanning for BLE devices..."));
  BLE.scan(); // broader scan; the device may hide services until connected
  unsigned long t0 = millis();

  while (millis() - t0 < SCAN_WINDOW_MS) {
    BLEDevice d = BLE.available();
    if (!d) { BLE.poll(); continue; }

    String name = d.localName();
    bool candidate = false; // only accept devices with a name like EY-...
    if (name.length() > 0 && NAME_HINT_PREFIX && strlen(NAME_HINT_PREFIX) > 0) {
      String u = name; u.toUpperCase();
      String p = NAME_HINT_PREFIX; p.toUpperCase();
      candidate = u.startsWith(p);
    }
    if (!candidate) continue;

    Serial.print(F("Found candidate: ")); Serial.println(name);

    BLE.stopScan();
    Serial.print(F("Connecting... "));
    if (!d.connect()) { Serial.println(F("FAILED")); BLE.scanForUuid(UUID_HID_SERVICE); continue; }
    Serial.println(F("OK"));

    dev = d;
    return discoverAndSubscribe();
  }
  return false;
}

void setup() {
  Serial.begin(115200);
  while (!Serial) {}
  delay(100);

  Serial.println();
  Serial.println(F("UNO R4 WiFi BLE host for Eyoyo (HID or vendor ASCII)"));

  if (!BLE.begin()) {
    Serial.println(F("BLE.begin() FAILED. Update UNO R4 WiFi connectivity firmware to >= 0.2.0."));
    while (1) { delay(500); Serial.print('.'); }
  }

  // Act as BLE Central
  BLE.setEventHandler(BLEDiscovered, nullptr);

  if (!connectToEyoyo()) {
    Serial.println(F("No suitable device yet. Will keep trying..."));
    Serial.println(F("Hint: Make sure phone apps (nRF Connect/Bluetooth) are disconnected, scanner is awake, and BLE suffix Enter/CR-LF is enabled."));
  }
}

void loop() {
  BLE.poll();

  if (!dev || !dev.connected()) {
    static unsigned long lastTry = 0;
    unsigned long now = millis();
    if (now - lastTry >= 3000) {
      lastTry = now;
      connectToEyoyo();
    }
    return;
  }

  // Handle Boot Keyboard Input
  if (bootKbdIn && bootKbdIn.valueUpdated()) {
    uint8_t r[20];
    int n = bootKbdIn.readValue(r, sizeof(r));
    handleBootKeyboardReport(r, n);
  }

  // Handle HID Report characteristics
  for (int i = 0; i < hidReportCount; i++) {
    if (hidReportChars[i] && hidReportChars[i].valueUpdated()) {
      uint8_t r[20];
      int n = hidReportChars[i].readValue(r, sizeof(r));
      // Try to interpret like boot keyboard if size looks like 8
      if (n >= 8) handleBootKeyboardReport(r, n);
      else handleAsciiBytes(r, n);
    }
  }

  // Fallback ASCII characteristic (notify or gentle poll)
  if (asciiFallback) {
    if (asciiFallback.valueUpdated()) {
      uint8_t r[64]; int n = asciiFallback.readValue(r, sizeof(r));
      handleAsciiBytes(r, n);
    } else if (asciiFallback.canRead()) {
      static uint8_t prev[64]; static int prevN = -1;
      uint8_t r[64]; int n = asciiFallback.readValue(r, sizeof(r));
      if (n > 0 && (n != prevN || memcmp(r, prev, n) != 0)) {
        handleAsciiBytes(r, n);
        prevN = n; memcpy(prev, r, n);
      }
    }
  }
}
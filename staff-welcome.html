<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CheckLoop — Welcome</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&display=swap" rel="stylesheet">
  <script src="config.js"></script>
  <link rel="stylesheet" href="staff.css">
  <style>
    /* === Welcome page visual refresh to match My Holidays glass theme === */
    .panel.light-panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid var(--border-color);
      color: var(--white);
    }
    .step-sub{ color: var(--muted) !important; font-weight:600; }

    /* Step 4 choice cards */
    #step4 #working-choice{ max-width: 780px; }
    #step4 #working-choice label{ display:block; }
    #step4 .choice-card{
      display:flex; align-items:center; justify-content:space-between; gap:12px; padding:16px 20px;
      border-radius:16px; border:1px solid var(--border-color);
      background: linear-gradient(145deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      color: var(--white); box-shadow: var(--shadow); transition: all .18s ease;
    }
    #step4 .choice-card:hover{ transform: translateY(-2px); background: rgba(255,255,255,0.08); }
    #step4 .choice-card .choice-title{ font-weight:800; font-size:16px; }
    #step4 .choice-card .choice-note{ font-size:13px; color: var(--muted); margin-top:4px; }
    #step4 .choice-card input[type="radio"]{ accent-color:#60a5fa; width:18px; height:18px; }
    #step4 .choice-card.is-selected{ border-color: rgba(59,130,246,.55); box-shadow: 0 8px 22px rgba(59,130,246,.18); background: linear-gradient(145deg, rgba(59,130,246,.15), rgba(99,102,241,.10)); }
    /* Gamified welcome vibe */
    .welcome-wrap{ position:relative; }
    .spark-bg{ position:absolute; inset:-40px; pointer-events:none; filter: blur(40px); opacity:.6; }
    .spark-bg::before{ content:""; position:absolute; inset:0; background:
      radial-gradient(400px 300px at 15% 20%, #8b5cf61a, transparent),
      radial-gradient(380px 260px at 85% 30%, #22c55e1a, transparent),
      radial-gradient(500px 320px at 50% 80%, #3b82f61a, transparent);
    }
  .hero-card{ position:relative; background: linear-gradient(145deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04)); border:1px solid var(--border-color); border-radius:20px; padding:22px; box-shadow: var(--shadow); overflow:hidden; color: var(--white); }
  .hero-card::after{ content: ''; position: absolute; inset: 0; border-radius: 20px; pointer-events: none; box-shadow: 0 0 0 1px rgba(59,130,246,0.04) inset; }
    .hero-top{ display:flex; align-items:center; gap:16px; justify-content:center; margin-bottom:8px; }
    .avatar{ width:64px; height:64px; border-radius:16px; display:grid; place-items:center; background:linear-gradient(135deg, var(--glass), var(--glass-2)); border:1px solid var(--border-color); box-shadow: var(--shadow); font-size:30px; color:var(--white); }
    .title{ font-size:24px; font-weight:900; letter-spacing:.2px; color:var(--white); }
    .subtitle{ color:var(--muted); font-weight:700; }
    .big-input{ display:flex; gap:10px; align-items:center; justify-content:center; margin-top:14px; }
  .big-input input{ flex:1; min-width:220px; max-width:360px; padding:14px 16px; border-radius:12px; border:1px solid var(--border-color); font-size:15px; background: rgba(255,255,255,0.06); color: var(--white); }
  .big-input input::placeholder{ color: var(--muted); }
    .meta-note{ color:var(--muted); font-size:12px; margin-top:8px; }
  /* Compact segmented control for Step 4 */
  #step4 .center-wrap{ display:flex; flex-direction:column; align-items:center; gap:12px; max-width:720px; margin:0 auto; }
  .seg-choice{ display:grid; grid-template-columns:1fr 1fr; gap:6px; width:min(520px, 100%); border-radius:14px; border:1px solid var(--border-color); background: rgba(255,255,255,0.06); padding:6px; box-shadow: var(--shadow); }
  .seg-choice input{ display:none; }
  .seg-choice label{ display:flex; flex-direction:column; align-items:center; justify-content:center; padding:10px 12px; border-radius:10px; font-weight:900; cursor:pointer; color:var(--muted); min-height:56px; text-align:center; line-height:1.1; }
  .seg-choice label span{ font-weight:600; font-size:12px; opacity:.85; }
  .seg-choice input:checked + label{ background: linear-gradient(135deg, #4338ca, #3b82f6); color:#fff; box-shadow: 0 8px 22px rgba(59,130,246,0.18); }
  body{ font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; color: var(--white); }

    /* selection helpers for role + avatar grid */
    .opt-selected{ outline: 2px solid var(--accent); box-shadow: 0 4px 12px #3b82f61a; }
    .avatar-grid-item{ transition: transform .12s ease, box-shadow .12s ease, outline-color .12s ease; }
    .avatar-grid-item:hover{ transform: translateY(-2px); box-shadow: 0 8px 18px rgba(2,6,23,.10); }

    .progress{ height:10px; border-radius:999px; background:#eef2ff; overflow:hidden; border:1px solid var(--border-color); }
    .progress > .bar{ height:100%; width:25%; background:linear-gradient(90deg,#60a5fa,#a78bfa); }

    /* Advanced Particle System */
    .confetti{ position:absolute; inset:0; pointer-events:none; overflow:hidden; z-index:20; }

    /* Particle Types */
    .particle{ position:absolute; will-change: transform, opacity; pointer-events:none; }

    /* Explosion Particles */
    .explosion-particle{
      width:8px; height:8px; border-radius:50%;
      animation: explode 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    }

    /* Sparkle Particles */
    .sparkle-particle{
      width:6px; height:6px;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: sparkle 1.8s ease-out forwards;
    }

    /* Burst Particles */
    .burst-particle{
      width:12px; height:4px; border-radius:6px;
      animation: burst 1.5s ease-out forwards;
    }

    /* Glow Particles */
    .glow-particle{
      width:14px; height:14px; border-radius:50%;
      filter: blur(2px); opacity:0.8;
      animation: glow 2.5s ease-out forwards;
    }

    /* Ring Particles */
    .ring-particle{
      width:20px; height:20px; border-radius:50%;
      border:2px solid; background:transparent;
      animation: ring-expand 2s ease-out forwards;
    }

    @keyframes explode{
      0%{ transform: translate(0,0) scale(1) rotate(0deg); opacity:1; }
      20%{ opacity:1; }
      100%{ transform: translate(var(--dx), var(--dy)) scale(0.3) rotate(var(--rotation)); opacity:0; }
    }

    @keyframes sparkle{
      0%{ transform: translate(0,0) scale(0) rotate(0deg); opacity:1; }
      15%{ transform: translate(calc(var(--dx)*0.15), calc(var(--dy)*0.15)) scale(1.2) rotate(72deg); opacity:1; }
      100%{ transform: translate(var(--dx), var(--dy)) scale(0) rotate(var(--rotation)); opacity:0; }
    }

    @keyframes burst{
      0%{ transform: translate(0,0) scale(1) rotate(var(--start-rotation)); opacity:1; }
      30%{ opacity:1; }
      100%{ transform: translate(var(--dx), var(--dy)) scale(0.5) rotate(calc(var(--start-rotation) + 180deg)); opacity:0; }
    }

    @keyframes glow{
      0%{ transform: translate(0,0) scale(0.5); opacity:0.8; filter: blur(2px); }
      25%{ transform: translate(calc(var(--dx)*0.3), calc(var(--dy)*0.3)) scale(1.5); opacity:1; filter: blur(1px); }
      100%{ transform: translate(var(--dx), var(--dy)) scale(0); opacity:0; filter: blur(4px); }
    }

    @keyframes ring-expand{
      0%{ transform: translate(0,0) scale(0.1); opacity:1; border-width:3px; }
      50%{ transform: translate(calc(var(--dx)*0.5), calc(var(--dy)*0.5)) scale(1.5); opacity:0.6; border-width:2px; }
      100%{ transform: translate(var(--dx), var(--dy)) scale(2.5); opacity:0; border-width:1px; }
    }

    /* Disney-style sparkle animations */
    .disney-sparkle {
      width: 8px;
      height: 8px;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: disneySparkle 2.5s ease-out forwards;
    }

    .disney-sparkle-burst {
      width: 6px;
      height: 6px;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: disneySparkleExplode 2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
    }

    .disney-magic-dust {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      animation: magicDustFloat 4s ease-out forwards;
    }

    @keyframes disneySparkle {
      0% { 
        transform: scale(0) rotate(0deg); 
        opacity: 1; 
        filter: brightness(2) saturate(1.5);
      }
      25% { 
        transform: scale(1.8) rotate(90deg); 
        opacity: 1; 
        filter: brightness(2.5) saturate(1.8);
      }
      75% { 
        transform: scale(1.2) rotate(270deg); 
        opacity: 0.8; 
        filter: brightness(1.8) saturate(1.3);
      }
      100% { 
        transform: scale(0) rotate(360deg); 
        opacity: 0; 
        filter: brightness(1) saturate(1);
      }
    }

    @keyframes disneySparkleExplode {
      0% { 
        transform: translate(0,0) scale(1.5) rotate(0deg); 
        opacity: 1; 
        filter: brightness(2.5) saturate(2);
      }
      20% { 
        transform: translate(calc(var(--dx)*0.2), calc(var(--dy)*0.2)) scale(2) rotate(var(--rotation)); 
        opacity: 1; 
        filter: brightness(2.2) saturate(1.8);
      }
      70% { 
        transform: translate(calc(var(--dx)*0.8), calc(var(--dy)*0.8)) scale(0.8) rotate(var(--rotation)); 
        opacity: 0.6; 
        filter: brightness(1.5) saturate(1.2);
      }
      100% { 
        transform: translate(var(--dx), var(--dy)) scale(0) rotate(var(--rotation)); 
        opacity: 0; 
        filter: brightness(1) saturate(1);
      }
    }

    @keyframes magicDustFloat {
      0% { 
        transform: translateY(0) scale(1); 
        opacity: 0.8; 
        filter: blur(1px);
      }
      50% { 
        transform: translateY(-60px) scale(1.5); 
        opacity: 1; 
        filter: blur(0.5px);
      }
      100% { 
        transform: translateY(-120px) scale(2); 
        opacity: 0; 
        filter: blur(3px);
      }
    }

    /* Balloon animation */
    @keyframes floatUp {
      0% { transform: translateY(0) rotate(-5deg); opacity: 1; }
      100% { transform: translateY(-600px) rotate(5deg); opacity: 0; }
    }

    /* Enhanced completion banner animation */
    @keyframes dynamicEntrance {
      0% {
        transform: translateY(50px) scale(0.8);
        opacity: 0;
        filter: blur(10px);
      }
      50% {
        transform: translateY(-10px) scale(1.05);
        opacity: 1;
        filter: blur(0px);
      }
      70% {
        transform: translateY(5px) scale(0.98);
      }
      100% {
        transform: translateY(0) scale(1);
        opacity: 1;
        filter: blur(0px);
      }
    }
    
    /* Avatar save pulse animation */
    @keyframes pulse{ 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
  /* Modern App-like Avatar Sections */
  .avatar-control-group{ 
    grid-column:1 / -1; 
    padding:14px; 
    margin-top:12px; 
    border-radius:16px; 
    background:linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); 
    box-shadow:0 8px 25px rgba(15,23,42,0.08), 0 3px 6px rgba(15,23,42,0.03); 
    border:1px solid rgba(148,163,184,0.12);
    position:relative;
    overflow:hidden;
    transition: all 0.3s ease;
  }
  .avatar-control-group::before{
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 4px;
    background: linear-gradient(90deg, #3b82f6, #8b5cf6, #06b6d4);
    border-radius: 20px 20px 0 0;
  }
  .avatar-control-group:hover{ 
    transform: translateY(-2px); 
    box-shadow:0 12px 35px rgba(15,23,42,0.12), 0 5px 15px rgba(15,23,42,0.06); 
  }
  .avatar-control-group + .avatar-control-group{ margin-top:20px; }
  .avatar-control-group .group-header{ 
    display:flex; 
    align-items:center; 
    justify-content:space-between; 
    gap:12px; 
    margin-bottom:12px;
  }
  .avatar-control-group .group-title{ 
    font-weight:800; 
    color:#1e293b; 
    margin:0; 
    font-size:16px; 
    display:flex;
    align-items:center;
    gap:8px;
  }
  .avatar-control-group .group-title::before{
    content: attr(data-icon);
    font-size: 20px;
    opacity: 0.8;
  }
  .avatar-control-group .group-help{ 
    color:#64748b; 
    font-size:14px; 
    margin:0 0 16px 0; 
    padding:12px 16px;
    background:rgba(59,130,246,0.05);
    border-radius:12px;
    border-left:3px solid #3b82f6;
    font-weight:500;
    display:none;
  }
  .avatar-control-group .group-grid{ 
    display:grid; 
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); 
    gap:12px; 
    align-items:start; 
    transition: all .35s cubic-bezier(0.4, 0, 0.2, 1); 
    max-height:2000px; 
    overflow:hidden; 
  }
  .avatar-control-group.collapsed .group-grid{ 
    max-height:0; 
    opacity:0; 
    pointer-events:none; 
    margin-top:0;
    padding-top:0;
  }
  .avatar-control-group.collapsed .group-help{ display:none; }
  .group-toggle{ 
    background:linear-gradient(135deg, #f1f5f9, #e2e8f0); 
    border:1px solid rgba(148,163,184,0.2); 
    padding:8px 16px; 
    border-radius:12px; 
    cursor:pointer; 
    font-weight:600; 
    color:#475569; 
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:0.5px;
    transition: all 0.2s ease;
  }
  .group-toggle:hover{
    background:linear-gradient(135deg, #e2e8f0, #cbd5e1);
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(15,23,42,0.1);
  }
  .group-toggle:active{ transform:translateY(0); }
  .avatar-control-group.collapsed .group-toggle{
    background:linear-gradient(135deg, #dbeafe, #bfdbfe);
    color:#1d4ed8;
  }

  /* Enhanced form controls */
  .avatar-control-group label{
    display:flex; 
    flex-direction:column; 
    gap:8px;
    padding:10px;
    background:rgba(255,255,255,0.7);
    border-radius:12px;
    border:1px solid rgba(148,163,184,0.1);
    transition: all 0.2s ease;
  }
  /* Compact mode for the avatar step */
  #welcome-step3 .panel{ padding:16px !important; border-radius:16px !important; }
  #welcome-step3 .panel + .panel{ margin-top:12px !important; }
  #welcome-step3 .group-toggle{ padding:6px 12px; font-size:11px; }
  #welcome-step3 select{ padding:10px 12px; font-size:13px; }
  .avatar-control-group label:hover{
    background:rgba(255,255,255,0.9);
    border-color:rgba(59,130,246,0.2);
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(15,23,42,0.05);
  }
  .avatar-control-group label span{
    font-weight:600; 
    color:#334155; 
    font-size:13px;
    text-transform:uppercase;
    letter-spacing:0.5px;
  }
  .avatar-control-group select{
    padding:12px 16px; 
    border-radius:10px; 
    border:1px solid rgba(148,163,184,0.2);
    background:white;
    font-size:14px;
    font-weight:500;
    color:#1e293b;
    transition: all 0.2s ease;
  }
  .avatar-control-group select:focus{
    outline:none;
    border-color:#3b82f6;
    box-shadow:0 0 0 3px rgba(59,130,246,0.1);
  }

  /* Option pills for role/team items */
  .option-pill{ display:flex; gap:10px; align-items:center; border-radius:12px; padding:10px; cursor:pointer; background:transparent; border:1px solid rgba(148,163,184,0.08); transition: all .12s ease; }
  .option-pill img{ width:32px; height:32px; object-fit:contain; }
  .option-pill input{ margin:0 8px 0 0; }
  .option-pill span{ font-weight:800; color: inherit; }
  .white-pill{ background:#fff; color:#0f172a; border-color: rgba(15,23,42,0.06); box-shadow: 0 6px 18px rgba(2,6,23,0.04); }

  /* New: replace bland selects with larger icon/button grids for better UX */
  .option-buttons{ display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
  .option-btn{ display:inline-flex; align-items:center; justify-content:center; gap:8px; padding:8px 10px; border-radius:10px; background:#fff; border:1px solid rgba(148,163,184,0.12); cursor:pointer; font-weight:700; color:#0f172a; min-width:56px; height:44px; box-shadow:0 6px 18px rgba(2,6,23,.04); transition:all .15s ease; }
  .option-btn:hover{ transform:translateY(-3px); box-shadow:0 10px 26px rgba(2,6,23,.08); }
  .option-btn.selected{ background:linear-gradient(90deg,#60a5fa,#a78bfa); color:white; border-color:transparent; }
  .option-swatch{ width:28px; height:28px; border-radius:6px; border:1px solid rgba(15,23,42,0.06); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06); }
  .select-hidden{ display:none !important; }

  /* Enhanced section styling */
  #group-face::before { background: linear-gradient(90deg, #f59e0b, #f97316); }
  #group-accessories::before { background: linear-gradient(90deg, #8b5cf6, #a855f7); }
  #group-hair::before { background: linear-gradient(90deg, #06b6d4, #0891b2); }

  /* Mobile responsiveness */
  @media (max-width: 768px) {
    .avatar-control-group .group-grid {
      grid-template-columns: 1fr;
    }
    .avatar-control-group {
      padding: 16px;
    }
  }
  </style>
</head>
<body>
  <div class="bg"><div class="wave"></div><div class="wave wave2"></div></div>
  <main class="content">
    <div class="topbar panel" style="position:relative;">
      <div class="halo"></div>
      <div class="nav seg-nav">
        <!-- Navigation will be rendered by staff-common.js -->
      </div>
      <div class="spacer"></div>
      <div class="pill" id="site-pill">Site: —</div>
      <div class="pill" id="email-pill">—</div>
      <div class="pill" id="role-pill">—</div>
      <button class="btn" id="logout-btn">Sign Out</button>
    </div>

    <!-- Welcome setup content -->
    <section id="welcome-step1" class="panel g-12 welcome-wrap" style="margin:0; display:flex; align-items:center; justify-content:center; min-height: 62vh;">
      <div class="spark-bg"></div>
      <div style="max-width:760px; width:100%;">
  <div class="hero-card panel light-panel">
          <div class="hero-top">
            <div class="avatar" aria-hidden="true"><img src="Icons/icons8-medical-mobile-app-100.png" alt="Welcome" style="width:42px;height:42px;object-fit:contain" onerror="this.onerror=null; this.src='https://img.icons8.com/fluency/96/hospital-3.png';"></div>
            <div>
              <div class="subtitle" id="site-subtitle">Welcome</div>
              <div class="title" id="welcome-title">Welcome</div>
            </div>
          </div>

          <div style="text-align:center; margin-top:8px;">
            <div style="font-weight:800;">What should we call you?</div>
            <div class="meta-note">Pick a name, others will see this.</div>
            <div class="big-input">
              <input id="nickname" placeholder="e.g. Ben" />
              <button class="btn" id="save-btn" style="padding:12px 20px; border-radius:14px; background:linear-gradient(135deg,#6495ff,#7b6bff); box-shadow:0 10px 30px rgba(101,137,255,0.24);">Get started</button>
            </div>
            <div id="save-msg" class="meta-note"></div>
          </div>

        </div>
      </div>
      <div class="confetti" id="confetti"></div>
    </section>

    <!-- Auto-hide any panels/controls that contain the literal text 'Change' on the avatar page -->
    <script>
      document.addEventListener('DOMContentLoaded', function(){
        // Scope to the avatar builder area when present
        const scope = document.getElementById('welcome-step3') || document.getElementById('welcome-step1') || document;
        if (!scope) return;
        try {
          // Search common clickable/label elements only inside the scope
          const candidates = Array.from(scope.querySelectorAll('button, a, span, div, label'));
          const changeEls = candidates.filter(el => {
            const txt = (el.textContent || '').trim();
            if (!txt) return false;
            // quick check for the word change, case-insensitive
            if (!/\bchange\b/i.test(txt)) return false;
            // ensure element is visible (handles display:none, detached nodes, etc.)
            const visible = (el.offsetWidth || el.offsetHeight || el.getClientRects().length);
            return !!visible;
          });
          changeEls.forEach(el => {
            // prefer to hide a sensible container so UI spacing collapses nicely
            const panel = el.closest('.avatar-control-group') || el.closest('.panel') || el.closest('section') || el.parentElement;
            if (panel) panel.style.display = 'none';
            else el.style.display = 'none';
          });
        } catch(e) {
          console.warn('hide-change-panels error', e);
        }
      });
    </script>

    <!-- Step 2 removed - going directly from nickname to avatar -->

    <!-- Step 3 (avatar builder) -->
      <section id="welcome-step3" class="panel g-12" style="display:none; margin:0;">
      <div class="panel-header" style="gap:10px; align-items:center;">
        <div class="illus-circle" style="width:64px;height:64px;"><img src="Icons/icons8-avatar-100.png" alt="Avatar" onerror="this.onerror=null; this.src='https://img.icons8.com/fluency/96/user-male-circle.png';"></div>
        <div class="panel-title">Create your avatar</div>
      </div>

      <div class="grid" style="gap:16px; align-items:start;">
        <div class="g-4" style="position: sticky; top: 20px; align-self: start;">
          <div class="panel" style="padding:16px;">
            <!-- Live preview header removed per user request -->
            <div style="display:grid; place-items:center;">
              <div id="avatar-preview-frame" style="width:200px; height:200px; border-radius:16px; border:1px solid rgba(2,6,23,0.06); background:#ffffff; display:grid; place-items:center; overflow:hidden; box-shadow:0 6px 18px rgba(2,6,23,0.08); position:relative;">
                <img id="avatarPreview" alt="Avatar preview" style="width:180px; height:180px; border-radius:12px; object-fit:contain; background:#fff; transition: all 0.3s ease;" />
              </div>
              <div style="display:flex; gap:12px; margin-top:20px;">
                <button class="btn btn-secondary" id="avatar-randomize" style="padding:12px 20px; border-radius:12px; font-weight:600; background:linear-gradient(135deg, #8b5cf6, #7c3aed); color:white; border:none;">🎲 Randomize</button>
                <button class="btn" id="avatar-save-manual" style="padding:12px 20px; border-radius:12px; font-weight:600; background:linear-gradient(135deg, #22c55e, #16a34a); color:white; border:none;">💾 Save Avatar</button>
              </div>
              <div class="meta-note" id="avatar-save-msg" style="margin-top:12px; text-align:center; font-weight:500;"></div>
            </div>
          </div>
        </div>

        <div class="g-8">
          <div class="panel" style="padding:24px; border:3px solid #3b82f6; border-radius:20px; background:linear-gradient(135deg, #dbeafe 0%, #bfdbfe 50%, #93c5fd 100%); position:relative; overflow:hidden;">
            <div style="position:absolute; top:0; left:0; right:0; height:6px; background:linear-gradient(90deg, #3b82f6, #8b5cf6, #06b6d4);"></div>
            <div style="font-weight:900; margin-bottom:12px; font-size:20px; color:#1e293b; display:flex; align-items:center; gap:10px;">
              🤖 AI Avatar Generator
            </div>
            <div style="background:rgba(255,255,255,0.8); border-radius:16px; padding:20px; margin-bottom:16px;">
              <div style="display:flex; gap:12px; align-items:flex-start;">
                <textarea id="avatarPrompt" rows="3" placeholder="🎨 Describe your perfect avatar: 'Friendly nurse with green scrubs, freckles, long brown hair, round glasses, colorful background'" style="flex:1; padding:14px 18px; border-radius:12px; border:2px solid rgba(59,130,246,0.2); font-size:14px; font-weight:500; resize:vertical; background:white;"></textarea>
                <button class="btn" id="avatar-ai-generate" style="white-space:nowrap; padding:14px 24px; background:linear-gradient(135deg, #10b981, #059669); color:white; border:none; border-radius:12px; font-weight:700; box-shadow:0 4px 12px rgba(16,185,129,0.3);">✨ Generate</button>
              </div>
              <div class="meta-note" id="avatar-ai-msg" style="margin-top:8px; font-weight:500;"></div>
            </div>
          </div>

          <div class="panel" style="padding:24px; margin-top:16px; border-radius:20px; background:linear-gradient(135deg, #ffffff 0%, #f8fafc 100%); box-shadow:0 8px 25px rgba(15,23,42,0.08);">
            <div style="font-weight:900; margin-bottom:16px; color:#1e293b; font-size:18px; display:flex; align-items:center; gap:8px;">
              ⚙️ Manual Controls
            </div>
            <div class="grid" style="gap:10px; grid-template-columns: repeat(2, minmax(0,1fr));">
              <!-- General -->
              <div id="layout-controls" style="display:none">
                <div style="grid-column:1 / -1; font-weight:700; color:var(--ink); padding-top:4px;">Layout</div>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Background Type</span>
                  <select id="opt-backgroundType" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);">
                    <option value="">Default</option>
                    <option value="solid">Solid</option>
                    <option value="gradientLinear">Gradient</option>
                  </select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Background Color</span>
                  <select id="opt-backgroundColor" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);">
                    <option value="">Default</option>
                    <option value="transparent">Transparent</option>
                    <option value="f2d3b1">Peach (f2d3b1)</option>
                    <option value="ecad80">Light Orange (ecad80)</option>
                    <option value="9e5622">Brown (9e5622)</option>
                    <option value="763900">Dark Brown (763900)</option>
                    <option value="ffffff">White (ffffff)</option>
                    <option value="f3f4f6">Gray (f3f4f6)</option>
                    <option value="93c5fd">Blue (93c5fd)</option>
                    <option value="a78bfa">Purple (a78bfa)</option>
                    <option value="22c55e">Green (22c55e)</option>
                    <option value="fca5a5">Pink (fca5a5)</option>
                  </select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Background Rotation</span>
                  <select id="opt-backgroundRotation" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);"></select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Radius</span>
                  <select id="opt-radius" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);"></select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Rotate</span>
                  <select id="opt-rotate" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);"></select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Scale</span>
                  <select id="opt-scale" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);">
                    <option value="50">50</option>
                    <option value="75">75</option>
                    <option value="100" selected>100</option>
                    <option value="125">125</option>
                    <option value="150">150</option>
                    <option value="175">175</option>
                    <option value="200">200</option>
                  </select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Flip</span>
                  <select id="opt-flip" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);">
                    <option value="">Default</option>
                    <option value="true">Yes</option>
                    <option value="false">No</option>
                  </select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Clip to Bounds</span>
                  <select id="opt-clip" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);">
                    <option value="">Default</option>
                    <option value="true">Yes</option>
                    <option value="false">No</option>
                  </select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Translate X</span>
                  <select id="opt-translateX" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);"></select>
                </label>
                <label style="display:flex; flex-direction:column; gap:6px;">
                  <span style="font-weight:700; color:var(--ink);">Translate Y</span>
                  <select id="opt-translateY" style="padding:10px 12px; border-radius:10px; border:1px solid var(--border-color);"></select>
                </label>
              </div>

              <div class="avatar-control-group" id="group-face">
                <div class="group-header">
                  <h4 class="group-title" data-icon="👤">Face & Expression</h4>
                  <button class="group-toggle" data-target="#group-face">Hide</button>
                </div>
                <div class="group-help">✨ Choose your facial features — eyes, mouth, and skin tone to create your unique look</div>
                <div class="group-grid">
                  <label>
                    <span>👁️ Eyes Style</span>
                    <select id="opt-eyes"></select>
                  </label>
                  <label>
                    <span>😊 Mouth Expression</span>
                    <select id="opt-mouth"></select>
                  </label>
                  <label>
                    <span>🤨 Eyebrows Shape</span>
                    <select id="opt-eyebrows"></select>
                  </label>
                  <label id="skin-swatch-wrapper">
                    <span>🎨 Skin Tone</span>
                    <div class="option-buttons" id="skin-swatch-buttons" role="group" aria-label="Skin tone options"></div>
                    <select id="opt-skinColor" class="select-hidden" aria-hidden="true" tabindex="-1"></select>
                  </label>
                </div>
              </div>
              <div class="avatar-control-group collapsed" id="group-accessories">
                <div class="group-header">
                  <h4 class="group-title" data-icon="👓">Accessories & Features</h4>
                  <button class="group-toggle" data-target="#group-accessories">Hide</button>
                </div>
                <div class="group-help">💎 Add personality with glasses, earrings, and distinctive features</div>
                <div class="group-grid">
                  <label>
                    <span>👓 Glasses Style</span>
                    <select id="opt-glasses">
                      <option value="">None</option>
                    </select>
                  </label>
                  <label style="display: none;">
                    <span>📊 Glasses Chance</span>
                    <select id="opt-glassesProbability"></select>
                  </label>
                  <label>
                    <span>💎 Earrings Type</span>
                    <select id="opt-earrings">
                      <option value="">None</option>
                    </select>
                  </label>
                  <label style="display: none;">
                    <span>📊 Earrings Chance</span>
                    <select id="opt-earringsProbability"></select>
                  </label>

                  <label style="grid-column:1 / -1;">
                    <span>✨ Special Features</span>
                    <select id="opt-features" multiple size="3"></select>
                  </label>
                  <label style="display: none;">
                    <span>📊 Features Chance</span>
                    <select id="opt-featuresProbability"></select>
                  </label>
                </div>
              </div>
              <div class="avatar-control-group collapsed" id="group-hair">
                <div class="group-header">
                  <h4 class="group-title" data-icon="💇">Hair & Style</h4>
                  <button class="group-toggle" data-target="#group-hair">Hide</button>
                </div>
                <div class="group-help">💅 Express yourself with different hairstyles and bold colors</div>
                <div class="group-grid">
                  <label>
                    <span>✂️ Hairstyle</span>
                    <select id="opt-hair"></select>
                  </label>
                  <label>
                    <span>🎨 Hair Color</span>
                    <select id="opt-hairColor"></select>
                  </label>
                  <label style="display: none;">
                    <span>📊 Hair Chance</span>
                    <select id="opt-hairProbability"></select>
                  </label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:20px;">
        <button class="btn btn-secondary" id="back-to-step1" style="padding:12px 24px; border-radius:12px; background:linear-gradient(135deg, #f1f5f9, #e2e8f0); color:#475569; border:none; font-weight:600;">← Back</button>
        <div style="display:flex; align-items:center; gap:12px;">
          <button class="btn" id="finish-avatar-btn" style="background:linear-gradient(135deg, #3b82f6, #1d4ed8); color:white; padding:12px 24px; border-radius:12px; font-weight:700; border:none; box-shadow:0 4px 12px rgba(59,130,246,0.3);">Finish Setup →</button>
        </div>
      </div>
      <div id="finish-avatar-msg" class="meta-note" style="text-align:center; margin-top:10px;"></div>
    </section>
    
    
    <!-- Step 4: Working Type Choice -->
    <section id="step4" class="panel g-12" style="display:none; margin:0;">
      <div class="panel-header" style="gap:10px; align-items:center;">
        <div class="illus-circle" style="width:64px;height:64px;"><img src="Icons/icons8-choice-64.png" alt="Working Type" onerror="this.onerror=null; this.src='https://img.icons8.com/fluency/96/split-files.png';"></div>
        <div class="panel-title" style="font-size:20px;">How do you record your work?</div>
      </div>
  <div class="step-sub" style="color:#64748b;">Choose whether you work in hours (HH:MM) or sessions.</div>
      <div id="working-choice" class="center-wrap">
        <div class="seg-choice" role="radiogroup" aria-label="Work recording type">
          <input id="work-type-hours" type="radio" name="work-type" value="hours" checked>
          <label for="work-type-hours">Hours (HH:MM)<span>e.g. 07:30</span></label>

          <input id="work-type-sessions" type="radio" name="work-type" value="sessions">
          <label for="work-type-sessions">Sessions<span>1 or 2 per day</span></label>
        </div>
        <div class="meta-note" id="step4-msg" style="min-height:20px;"></div>
      </div>
      <div style="display:flex; justify-content:space-between; margin-top:24px;">
        <button class="btn btn-secondary" id="step4-back">← Back</button>
        <button class="btn" id="step4-next">Continue →</button>
      </div>
    </section>

    <!-- Step 4b: Working Pattern (Sunday → Saturday) -->
    <section id="working-pattern-step" class="panel g-12" style="display:none; margin:0;">
      <div class="panel-header" style="gap:10px; align-items:center;">
        <div class="illus-circle" style="width:64px;height:64px;"><img src="Icons/icons8-calendar-64.png" alt="Working Pattern" onerror="this.onerror=null; this.src='https://img.icons8.com/fluency/96/calendar-31.png';"></div>
        <div class="panel-title" style="font-size:20px;">Your weekly working pattern</div>
      </div>
  <div class="step-sub" style="color:#64748b;">Enter your typical hours or sessions for each day.</div>
      <div id="working-pattern-form" style="display:flex; flex-direction:column; gap:12px; max-width:720px;">
        <div class="tiny-note" id="working-pattern-note" style="color:#6b7280; font-size:12px; margin-bottom:6px;"></div>
      </div>
      <div id="working-pattern-msg" class="meta-note" style="min-height:20px;"></div>
      <div style="display:flex; justify-content:space-between; margin-top:18px;">
        <button class="btn btn-secondary" id="working-pattern-back">← Back</button>
        <button class="btn" id="working-pattern-finish">🎉 Finish Setup</button>
      </div>
    </section>

    <!-- Step 5: Completion -->
    <section id="step5" class="panel g-12" style="display:none; margin:0; position:relative; min-height:400px;">
      <div id="confetti-container" class="confetti"></div>
      <div style="position:relative; z-index:10; padding:40px; text-align:center;">
        <div style="font-size:80px; margin-bottom:20px;">🎉🎈🎊</div>
        <div class="complete-banner" style="background:linear-gradient(90deg,#22c55e,#16a34a); color:#fff; padding:20px 30px; border-radius:20px; font-weight:800; font-size:24px; display:inline-flex; align-items:center; gap:12px; justify-content:center; box-shadow:0 10px 28px rgba(22,163,74,0.30); animation: dynamicEntrance 1.2s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;">
          All Set! You're Amazing!
        </div>
        <div style="margin-top:20px; font-size:18px; color:#64748b; font-weight:600;">
          Great job completing your profile!
        </div>
        <div class="meta-note center" style="margin-top:14px;">Redirecting to your dashboard in a moment...</div>
      </div>
    </section>
  </main>

  <script type="module">
  import { initSupabase, requireStaffSession, getSiteText, setTopbar, handleAuthState, navActivate, attachLogout } from './staff-common.js';

  // Visual selection state for Step 4 segmented control (styles handled by :checked + label)
  (function(){
    const wrap = document.getElementById('working-choice');
    if (!wrap) return;
    const apply = () => {
      const checked = wrap.querySelector('input[name="work-type"]:checked');
      if (!checked) return; // styles applied via CSS
    };
    wrap.addEventListener('change', e => { if (e.target && e.target.name === 'work-type') apply(); });
    apply();
  })();

  // Compact: sync Hide/Show buttons and allow collapsing groups
  (function(){
    const sync = (btn, target) => { btn.textContent = target.classList.contains('collapsed') ? 'Show' : 'Hide'; };
    document.querySelectorAll('.group-toggle').forEach(btn => {
      const sel = btn.getAttribute('data-target');
      const target = document.querySelector(sel);
      if (!target) return;
      sync(btn, target);
      btn.addEventListener('click', () => { target.classList.toggle('collapsed'); sync(btn, target); });
    });
  })();

  // Simple HTML escaper used when rendering dynamic labels/values
  function esc(s){ return (s ?? "").toString().replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
    
    // Make supabase globally available for AI generation
    let globalSupabase;
    
    (async function(){
      const supabase = await initSupabase();
      // Make supabase available globally for Admin Portal button
      window.supabase = supabase;
      globalSupabase = supabase; // Store in global variable
      handleAuthState(supabase);
      // Always show navigation for welcome page
      navActivate('welcome');
      attachLogout(supabase);

      // Debug logs: capture localStorage and session state to diagnose session persistence
      try {
        console.log('[welcome debug] localStorage keys (supabase-related):', Object.keys(localStorage || {}).filter(k => k.startsWith('sb-') || k.includes('supabase') || k.startsWith('auth')));
      } catch (e) { console.warn('[welcome debug] localStorage read failed', e); }
      try {
        if (supabase && supabase.auth && typeof supabase.auth.getSession === 'function') {
          const sessRes = await supabase.auth.getSession();
          console.log('[welcome debug] supabase.auth.getSession result:', sessRes);
        } else {
          console.log('[welcome debug] supabase.auth.getSession not available yet');
        }
      } catch (e) { console.warn('[welcome debug] supabase.getSession threw', e); }

      // Admin nav removed - separate staff portal

      try{
        const { session, profileRow } = await requireStaffSession(supabase);
        const user = session.user;

        // Get site_id from multiple sources in priority order
        const sessionSiteId = sessionStorage.getItem('userSiteId');
        const siteId = profileRow?.site_id ||
                      user?.user_metadata?.site_id ||
                      user?.raw_user_meta_data?.site_id ||
                      (sessionSiteId ? parseInt(sessionSiteId) : null) ||
                      2; // Default to site 2 as last resort (common site)

        console.log('Site determination:', {
          profileSite: profileRow?.site_id,
          userMetaSite: user?.user_metadata?.site_id,
          rawMetaSite: user?.raw_user_meta_data?.site_id,
          sessionSite: sessionSiteId,
          finalSite: siteId
        });

        // Store globally for handlers
        window.currentUser = user;
        window.currentSiteId = siteId;
        const role = profileRow?.role || user?.raw_user_meta_data?.role || 'Staff';
        const roleDetail = role.charAt(0).toUpperCase() + role.slice(1);  // Capitalize first letter

        // Check if user already has been pre-configured by admin
        let preConfigured = false;
        let existingData = {};

        // Check server state for profile completion
        try {
          const siteIdForCheck = siteId;
          let nickname = null, roleDetailCheck = null, teamId = null, teamName = null, avatarUrl = null;

          // First check site_invites for pre-configuration metadata
          const { data: inviteData } = await supabase
            .from('site_invites')
            .select('metadata')
            .eq('email', user.email)
            .eq('site_id', siteIdForCheck)
            .maybeSingle();

          if (inviteData?.metadata) {
            console.log('Found pre-configuration data from invitation:', inviteData.metadata);
            existingData.inviteMetadata = inviteData.metadata;
            preConfigured = true;

            // Set pre-configured values
            if (inviteData.metadata.job_role) {
              roleDetailCheck = inviteData.metadata.job_role;
              window.preConfiguredRole = inviteData.metadata.job_role;
            }
            if (inviteData.metadata.team_id) {
              teamId = inviteData.metadata.team_id;
              window.preConfiguredTeamId = inviteData.metadata.team_id;
            }
            if (inviteData.metadata.working_pattern) {
              window.preConfiguredWorkingPattern = inviteData.metadata.working_pattern;
            }
            if (inviteData.metadata.holiday_entitlement) {
              window.preConfiguredHolidayEntitlement = inviteData.metadata.holiday_entitlement;
            }
          }

          // Check if user has existing data in various tables
          const [masterData, workingPattern, holidayProfile] = await Promise.all([
            supabase.from('master_users')
              .select('nickname, role_detail, team_id, team_name, avatar_url')
              .eq('auth_user_id', user.id)
              .eq('site_id', siteIdForCheck)
              .maybeSingle(),
            supabase.from('3_staff_working_patterns')
              .select('*')
              .eq('user_id', user.id)
              .maybeSingle(),
            supabase.from('1_staff_holiday_profiles')
              .select('*')
              .eq('email', user.email)
              .maybeSingle()
          ]);

          // Store existing data for pre-population
          if (masterData.data) {
            existingData.master = masterData.data;
            nickname = masterData.data.nickname;
            roleDetailCheck = masterData.data.role_detail;
            teamId = masterData.data.team_id;
            teamName = masterData.data.team_name;
            avatarUrl = masterData.data.avatar_url;
            // If we have role and team data, user was pre-configured
            if (roleDetailCheck && (teamId || teamName)) {
              preConfigured = true;
            }
          }

          if (workingPattern.data) {
            existingData.workingPattern = workingPattern.data;
            preConfigured = true;
          }

          if (holidayProfile.data) {
            existingData.holidayProfile = holidayProfile.data;
          }

          // Also check user metadata for pre-configuration
          if (user.raw_user_meta_data?.job_role || user.raw_user_meta_data?.role_detail) {
            preConfigured = true;
            if (!roleDetailCheck) roleDetailCheck = user.raw_user_meta_data?.job_role || user.raw_user_meta_data?.role_detail;
          }

          window.preConfiguredData = existingData;
          window.isPreConfigured = preConfigured;

          // Initialize selectedRole from admin-provided data now that all data is loaded
          window.selectedRole = getUserRole();
          console.log('Initialized selectedRole from admin data:', window.selectedRole);

          if (preConfigured) {
            console.log('User was pre-configured by admin:', existingData);
          }

          if (siteIdForCheck && !masterData.data) {
            const { data: masterSnapshot } = await supabase
              .from('master_users')
              .select('nickname, role_detail, team_id, team_name, avatar_url')
              .eq('auth_user_id', user.id)
              .eq('site_id', siteIdForCheck)
              .order('updated_at', { ascending: false })
              .limit(1)
              .maybeSingle();
            if (masterSnapshot) { nickname = masterSnapshot.nickname; roleDetailCheck = masterSnapshot.role_detail; teamId = masterSnapshot.team_id; teamName = masterSnapshot.team_name; avatarUrl = masterSnapshot.avatar_url; }
          }
          if (!nickname || !roleDetailCheck || (!teamId && !teamName) || !avatarUrl) {
            try {
              const { data: p } = await supabase
                .from('profiles')
                .select('nickname, role_detail, team_id, team_name, avatar_url')
                .eq('user_id', user.id)
                .maybeSingle();
              if (p) {
                nickname = nickname || p.nickname;
                roleDetailCheck = roleDetailCheck || p.role_detail;
                teamId = teamId || p.team_id;
                teamName = teamName || p.team_name;
                avatarUrl = avatarUrl || p.avatar_url;
              }
            } catch(_) { /* ignore */ }
          }
          // Check if user is a known staff member who should bypass strict onboarding requirements
          const knownStaffEmails = ['benhowardmagic@hotmail.com', 'ben.howard@stoke.nhs.uk'];
          const isKnownStaff = knownStaffEmails.includes(user.email);

          // Don't force onboarding regardless of profile completion
          // Users can complete their profile at their leisure
        } catch(_) { /* soft-fail */ }

        // Always show navigation and topbar
        setTopbar({ siteText: await getSiteText(supabase, siteId), email: user.email, role: roleDetail });

        // Working hours step removed; no handler pre-binding needed.

  // === Persist Role/Team and Avatar helpers (fixes: page 2 + avatar not saving) ===

        function buildIsGpFlag(roleStr){
          if (!roleStr) return false;
          return /(^|\s)(gp|doctor|dr\.?)(\s|$)/i.test(String(roleStr));
        }
        // Expose for other scopes
        window.buildIsGpFlag = buildIsGpFlag;

        // Resolve GP flag preferring role text over DB value
        async function resolveIsGp(currentUser, currentSiteId) {
          // First: if role clearly indicates GP/Doctor, treat as GP
          const roleText = (typeof window.getUserRole === 'function') ? window.getUserRole() : (window.selectedRole || 'staff');
          if (buildIsGpFlag(roleText)) return true;

          // Next: fall back to DB value if available
          if (typeof window.currentMasterIsGp === 'boolean') return window.currentMasterIsGp;
          try {
            const { data } = await globalSupabase
              .from('master_users')
              .select('is_gp')
              .eq('auth_user_id', currentUser.id)
              .eq('site_id', currentSiteId)
              .maybeSingle();
            if (typeof data?.is_gp === 'boolean') return data.is_gp;
          } catch(_) {}
          return false;
        }
        // Expose for click handlers bound elsewhere
        window.resolveIsGp = resolveIsGp;

        // Helper function to get the user's role from various sources (admin-provided data)
        function getUserRole() {
          // Priority order for role determination:
          // 1. Pre-configured role from admin invitation
          // 2. Role from user metadata (set during invitation)
          // 3. Role from existing database records
          // 4. window.selectedRole (fallback for manual selection)
          
          const user = window.currentUser;
          
          // First check pre-configured role from admin invitation
          if (window.preConfiguredRole) {
            console.log('Using pre-configured role from admin invitation:', window.preConfiguredRole);
            return window.preConfiguredRole;
          }
          
          // Check user metadata (set during invitation process)
          if (user?.raw_user_meta_data?.role_detail) {
            console.log('Using role_detail from user metadata:', user.raw_user_meta_data.role_detail);
            return user.raw_user_meta_data.role_detail;
          }
          
          if (user?.raw_user_meta_data?.job_role) {
            console.log('Using job_role from user metadata:', user.raw_user_meta_data.job_role);
            return user.raw_user_meta_data.job_role;
          }
          
          if (user?.user_metadata?.role_detail) {
            console.log('Using role_detail from user metadata:', user.user_metadata.role_detail);
            return user.user_metadata.role_detail;
          }
          
          // Fallback to window.selectedRole if it exists (for backward compatibility)
          if (window.selectedRole) {
            console.log('Using fallback window.selectedRole:', window.selectedRole);
            return window.selectedRole;
          }
          
          console.log('No role found, defaulting to Staff');
          return 'Staff';
        }

        function resolveSelectedRoleTeam(){
          // Prefer globals set by existing handlers
          const role = window.selectedRole || null;
          const teamId = (typeof window.selectedTeamId !== 'undefined') ? window.selectedTeamId : null;
          const teamName = window.selectedTeamName || null;

          // Fallbacks: try to infer from DOM if globals aren't set
          let roleFallback = role;
          try {
            if (!roleFallback) {
              const el = document.querySelector('#role-grid .opt-selected, #role-grid .selected, #role-grid [aria-checked="true"], #role-grid input[type=radio]:checked, #role-grid [data-role]');
              roleFallback = el?.dataset?.role || el?.value || (el?.textContent || '').trim() || null;
            }
          } catch(_) {}

          let teamIdFallback = teamId, teamNameFallback = teamName;
          try {
            if (!teamIdFallback && !teamNameFallback) {
              const el = document.querySelector('#team-grid .opt-selected, #team-grid .selected, #team-grid [aria-checked="true"], #team-grid input[type=radio]:checked, #team-grid [data-team-id], #team-grid [data-team-name]');
              teamIdFallback = el?.dataset?.teamId ? Number(el.dataset.teamId) : (el?.value ? Number(el.value) : null);
              teamNameFallback = el?.dataset?.teamName || (el?.textContent || '').trim() || null;
            }
          } catch(_) {}

          return {
            role: roleFallback,
            teamId: (Number.isFinite(teamIdFallback) ? teamIdFallback : null),
            teamName: teamNameFallback
          };
        }

        async function persistRoleTeam(roleIn, teamIdIn, teamNameIn){
          const { role, teamId, teamName } = resolveSelectedRoleTeam();
          const finalRole = roleIn || role || null;
          const finalTeamId = (typeof teamIdIn !== 'undefined' ? teamIdIn : teamId);
          const finalTeamName = (typeof teamNameIn !== 'undefined' ? teamNameIn : teamName);
          const nickVal = String(document.getElementById('nickname')?.value || '').trim() || null;

          // ADMIN PROTECTION: Check if user has admin access before overwriting role
          const isAdmin = user?.user_metadata?.admin_access === true;
          console.log('[persistRoleTeam] Admin check:', { isAdmin, currentRole: user?.user_metadata?.role, finalRole });

          // 1) auth metadata
          try {
            const updateData = {
              team_id: finalTeamId || null,
              team_name: finalTeamName || null,
              nickname: nickVal || null
            };

            // If user is admin, preserve admin role but store job role separately
            if (isAdmin) {
              updateData.role = 'admin'; // Keep admin role
              updateData.role_detail = 'Admin'; // Keep admin display
              updateData.job_role = finalRole; // Store their clinical role separately
              console.log('[persistRoleTeam] Preserving admin role, storing job role:', finalRole);
            } else {
              updateData.role_detail = finalRole;
              console.log('[persistRoleTeam] Setting role for non-admin:', finalRole);
            }

            await supabase.auth.updateUser({ data: updateData });
          } catch (e) {
            console.warn('[persistRoleTeam] auth.updateUser failed', e);
          }

          // 2) Update master_users table (primary source of truth)
          try {
            // Determine the access_type based on role
            let accessType = 'staff';
            if (isAdmin || user?.user_metadata?.role?.toLowerCase() === 'admin') {
              accessType = 'admin';
            } else if (user?.user_metadata?.role?.toLowerCase() === 'owner') {
              accessType = 'owner';
            } else if (user?.user_metadata?.role?.toLowerCase() === 'manager') {
              accessType = 'manager';
            }

            const masterUpdate = {
              role_detail: finalRole,
              team_id: finalTeamId,
              team_name: finalTeamName,
              updated_at: new Date().toISOString()
            };

            // Only update nickname if it exists
            if (nickVal) {
              masterUpdate.nickname = nickVal;
            }

            console.log('[persistRoleTeam] Updating master_users with:', masterUpdate);

            const { error: masterError } = await supabase
              .from('master_users')
              .update(masterUpdate)
              .eq('auth_user_id', user.id)
              .eq('site_id', siteId);

            if (masterError) {
              console.error('[persistRoleTeam] master_users update error:', masterError);
            } else {
              console.log('[persistRoleTeam] Successfully updated master_users');
            }
          } catch (e) {
            console.error('[persistRoleTeam] master_users exception:', e);
          }

          // 3) profiles table is no longer used - master_users is the primary source
          // Commenting out profiles update to prevent confusion
          /*
          try {
            const profileData = {
              user_id: user.id,
              site_id: siteId || null,
              nickname: nickVal || null
            };
            const { error: profileErr } = await supabase.from('profiles').upsert(profileData);
            if (profileErr) console.warn('[persistRoleTeam] profiles upsert error', profileErr);
          } catch (e) {
            console.warn('[persistRoleTeam] profiles upsert failed', e);
          }
          */

          // 3) staff_app_welcome removed - master_users is now the primary source of truth
          // No longer writing to staff_app_welcome table

          // 4) 1_staff_holiday_profiles (keep role/team in sync)
          try {
            // Resolve existing profile id by user_id or email
            let profileId = null;
            try {
              const { data: byUser } = await supabase
                .from('1_staff_holiday_profiles')
                .select('id')
                .eq('user_id', user.id)
                .maybeSingle();
              if (byUser?.id) profileId = byUser.id;
            } catch(_) {}
            let email = user.email || null;
            if (!profileId && email) {
              try {
                const { data: byEmail } = await supabase
                  .from('1_staff_holiday_profiles')
                  .select('id')
                  .eq('email', email)
                  .maybeSingle();
                if (byEmail?.id) profileId = byEmail.id;
              } catch(_) {}
            }

            // Build upsert payload
            const hp = {
              user_id: user.id,
              email: email,
              full_name: (user.user_metadata?.full_name || user.user_metadata?.name || null),
              site_id: siteId || null,
              role: finalRole,
              team_name: finalTeamName || null,
              is_gp: buildIsGpFlag(finalRole)
            };

            // If your table uses a unique constraint on email (common), target it; else plain upsert
            const up = supabase.from('1_staff_holiday_profiles');
            const { error: hpErr } = profileId
              ? await up.update(hp).eq('id', profileId)
              : await up.upsert(hp, { onConflict: 'email' });
            if (hpErr) console.warn('[persistRoleTeam] 1_staff_holiday_profiles upsert error', hpErr);
          } catch (e) {
            console.warn('[persistRoleTeam] holiday profile upsert failed', e);
          }

          return { role: finalRole, teamId: finalTeamId, teamName: finalTeamName };
        }

        // This function is now defined later in the avatar section
        // We'll use the consolidated version that saves to all tables

        // Bind saves to navigation buttons so data is persisted at each step
        (function bindPage2Saves(){
          const btn = document.getElementById('to-avatar-btn');
          if (!btn || btn.dataset.roleTeamPersistBound === '1') return;
          btn.addEventListener('click', async () => {
            try {
              const r = await persistRoleTeam();
              const msg = document.getElementById('finish-msg') || document.getElementById('role-msg');
              if (msg) msg.textContent = r.role ? `Saved role: ${r.role}${r.teamName ? `, team: ${r.teamName}` : ''}` : 'Saved.';
            } catch (e) {
              console.warn('[bindPage2Saves] persist failed', e);
              const msg = document.getElementById('finish-msg') || document.getElementById('role-msg');
              if (msg) msg.textContent = '⚠️ Could not save your role/team — we will retry on the next step.';
            }
          }, { once: true });
          btn.dataset.roleTeamPersistBound = '1';
        })();

        (function bindAvatarFinishSave(){
          const btn = document.getElementById('finish-avatar-btn');
          if (!btn || btn.dataset.avatarPersistBound === '1') return;
          btn.addEventListener('click', async () => {
            try {
              // Ensure role/team also persisted before moving on
              await persistRoleTeam();
              const imgEl = document.getElementById('avatarPreview');
              let url = imgEl?.getAttribute('src') || window.currentAvatarUrl || (typeof buildAvatarUrlFromControls === 'function' ? buildAvatarUrlFromControls() : null);
              if (!url && typeof updateAvatarPreview === 'function') {
                updateAvatarPreview();
                url = document.getElementById('avatarPreview')?.getAttribute('src') || null;
              }
              if (url && window.saveAvatarToSupabase) await window.saveAvatarToSupabase(url);
              const msg = document.getElementById('avatar-save-msg');
              if (msg) msg.textContent = '✅ Avatar saved. Finishing setup...';
            } catch (e) {
              console.warn('[bindAvatarFinishSave] save failed', e);
            }
          }, { once: true });
          btn.dataset.avatarPersistBound = '1';
        })();

        // COMMENTED OUT: This function tries to call persistRoleTeam which is not in scope
        // The actual working hours saving is handled by setupWorkingHoursHandlers
        /*
        (function bindFinalSave(){
          const btn = document.getElementById('complete-setup');
          if (!btn || btn.dataset.finalPersistBound === '1') return;
          btn.addEventListener('click', async () => {
            try {
              await persistRoleTeam();
              const imgEl = document.getElementById('avatarPreview');
              let url = imgEl?.getAttribute('src') || window.currentAvatarUrl || (typeof buildAvatarUrlFromControls === 'function' ? buildAvatarUrlFromControls() : null);
              if (!url && typeof updateAvatarPreview === 'function') {
                updateAvatarPreview();
                url = document.getElementById('avatarPreview')?.getAttribute('src') || null;
              }
              if (url && window.saveAvatarToSupabase) await window.saveAvatarToSupabase(url);
            } catch (e) {
              console.warn('[bindFinalSave] save failed', e);
            }
          }, { once: true });
          btn.dataset.finalPersistBound = '1';
        })();
        */

        // === /Persist Role/Team and Avatar helpers ===
        // Adds two new fields to the entitlement payload:
        //   - calc_multiplier (defaults to 6 unless you change it below)
        //   - calc_output_hours (weeklyHours * calc_multiplier)
        //
        // This runs when the user taps "🎉 Finish Setup" after entering working hours.
        // It ensures a row exists in 2_staff_entitlements for the current year.

        // Helper: fetch the current working pattern row and derive weekly hours and sessions
        async function fetchWeeklyTotalsFromWorkingPattern(userId, siteId) {
          // Pull whatever columns exist for hours/sessions; we will sum by day.
          const { data: wp, error } = await supabase
            .from('3_staff_working_patterns')
            .select('*')
            .eq('user_id', userId)
            .eq('site_id', siteId)
            .maybeSingle();

          if (error) {
            console.warn('[entitlement] working_patterns select error', error);
            return { weeklyHours: 0, weeklySessions: 0 };
          }
          if (!wp) return { weeklyHours: 0, weeklySessions: 0 };

          // Use the pre-calculated totals if available
          if (wp.total_hours !== undefined && wp.total_sessions !== undefined) {
            console.log('[entitlement] Using pre-calculated totals - hours:', wp.total_hours, 'sessions:', wp.total_sessions);
            return { weeklyHours: wp.total_hours || 0, weeklySessions: wp.total_sessions || 0 };
          }

          // Fallback: calculate from individual days
          const days = ['monday','tuesday','wednesday','thursday','friday','saturday','sunday'];
          let hoursSum = 0;
          let sessionsSum = 0;

          for (const day of days) {
            const h = wp[`${day}_hours`];
            const s = wp[`${day}_sessions`];

            // Handle HH:MM format for hours
            if (h && typeof h === 'string' && h.includes(':')) {
              const [hours, minutes] = h.split(':').map(Number);
              hoursSum += hours + (minutes / 60);
            } else if (typeof h === 'number') {
              hoursSum += h;
            }

            if (typeof s === 'number' && !Number.isNaN(s)) sessionsSum += s;
          }

          return { weeklyHours: hoursSum, weeklySessions: sessionsSum };
        }

        // Helper: resolve staff_profile_id for the current user
        async function resolveStaffProfileId(user) {
          // Try by user_id
          try {
            const { data: byUser } = await supabase
              .from('1_staff_holiday_profiles')
              .select('id')
              .eq('user_id', user.id)
              .maybeSingle();
            if (byUser?.id) return byUser.id;
          } catch (_) {}

          // Fallback by email (profiles were historically keyed by unique email)
          try {
            const { data: byEmail } = await supabase
              .from('1_staff_holiday_profiles')
              .select('id')
              .eq('email', user.email)
              .maybeSingle();
            if (byEmail?.id) return byEmail.id;
          } catch (_) {}

          console.warn('[entitlement] No staff_profile_id could be resolved for user', user.id);
          return null;
        }

        // Main: ensure there is a current-year entitlement row with the new structure
        async function ensureEntitlementForUser(user, siteId, totals, isGP) {
          const staffProfileId = await resolveStaffProfileId(user);
          if (!staffProfileId) return;

          const year = new Date().getFullYear();

          // Default multiplier as requested
          const defaultMultiplier = 6;

          const payload = {
            staff_id: staffProfileId,
            year: year,
            weekly_hours: isGP ? null : totals.weeklyHours,
            weekly_sessions: isGP ? totals.weeklySessions : null,
            multiplier: defaultMultiplier
          };

          console.log('[entitlement] Creating entitlement - isGP:', isGP, 'totals:', totals, 'payload:', payload);

          const { error: upErr } = await supabase
            .from('2_staff_entitlements')
            .upsert(payload, { onConflict: 'staff_id,year' });

          if (upErr) {
            console.warn('[entitlement] upsert error', upErr);
          } else {
            console.log('[entitlement] upserted entitlement row', payload);
          }
        }

        // Working hours step removed — entitlement update will not run here.
        // Clean up any old force onboarding data
        // Already cleaned up above

        const fullName = profileRow?.full_name || user?.raw_user_meta_data?.full_name || (user?.email?.split('@')[0]) || 'there';
        document.getElementById('welcome-title').textContent = `Welcome, ${fullName}`;

        // Try to read any existing nickname if the column exists
        let nicknameColumnExists = true;
        try {
          const selCols = ['user_id','full_name','site_id','role','nickname'];
          const { data, error } = await supabase
            .from('profiles')
            .select(selCols.join(','))
            .eq('user_id', user.id)
            .maybeSingle();
          if (error) {
            if (String(error.code) === '42703' || /column .*nickname/i.test(String(error.message))) {
              nicknameColumnExists = false;
            } else {
              console.warn('[staff-welcome] profiles select error', error);
            }
          } else if (data && data.nickname) {
            document.getElementById('nickname').value = data.nickname;
          }
        } catch (e) {
          nicknameColumnExists = false;
        }

        // ---- Step 3: DiceBear Avatar Builder (Adventurer) ----
        function rangeArr(start, end, step=1){ const a=[]; for(let i=start;i<=end;i+=step) a.push(i); return a; }
        function pad2(n){ return String(n).padStart(2,'0'); }

        function buildAvatarUrlFromControls(){
          const base = 'https://api.dicebear.com/7.x/adventurer/svg';
          const seed = encodeURIComponent(
            (window.aiSeed && String(window.aiSeed)) ||
            (document.getElementById('nickname')?.value || '').trim() ||
            (typeof fullName === 'string' && fullName) ||
            'User'
          );
          const params = new URLSearchParams();
          params.set('seed', seed);

          const bgType = document.getElementById('opt-backgroundType').value;
          const bgColor = document.getElementById('opt-backgroundColor').value;
          const bgRot = document.getElementById('opt-backgroundRotation').value;
          const radius = document.getElementById('opt-radius').value;
          const rotate = document.getElementById('opt-rotate').value;
          const scale = document.getElementById('opt-scale').value;
          const flip = document.getElementById('opt-flip').value;
          const clip = document.getElementById('opt-clip').value;
          const tx = document.getElementById('opt-translateX').value;
          const ty = document.getElementById('opt-translateY').value;

          const eyes = document.getElementById('opt-eyes').value;
          const mouth = document.getElementById('opt-mouth').value;
          const eyebrows = document.getElementById('opt-eyebrows').value;
          const glasses = document.getElementById('opt-glasses').value;
          let glassesProbability = document.getElementById('opt-glassesProbability').value;
          const earrings = document.getElementById('opt-earrings').value;
          let earringsProbability = document.getElementById('opt-earringsProbability').value;
          const featuresSel = document.getElementById('opt-features');
          let featuresProbability = document.getElementById('opt-featuresProbability').value;
          const hair = document.getElementById('opt-hair').value;
          const hairColor = document.getElementById('opt-hairColor').value;
          let hairProbability = document.getElementById('opt-hairProbability').value;
          const skinColor = document.getElementById('opt-skinColor').value;

          // Ensure selected accessories/styles are visible by default
          // If a style is chosen but probability is blank, default to 100
          const ensureProb = (styleVal, probVal, probId) => {
            if (styleVal && !String(probVal || '').trim()) {
              const el = document.getElementById(probId);
              if (el) el.value = '100';
              return '100';
            }
            return probVal;
          };
          glassesProbability = ensureProb(glasses, glassesProbability, 'opt-glassesProbability');
          earringsProbability = ensureProb(earrings, earringsProbability, 'opt-earringsProbability');
          // For features (multi-select), if any chosen and no probability, set to 100
          const featuresChosen = featuresSel ? Array.from(featuresSel.selectedOptions).some(o => !!o.value) : false;
          if (featuresChosen) {
            featuresProbability = ensureProb('features', featuresProbability, 'opt-featuresProbability');
          }
          // For hair, if a non-blank style picked and no probability, set to 100
          hairProbability = ensureProb(hair, hairProbability, 'opt-hairProbability');

          if (bgType) params.set('backgroundType', bgType);
          if (bgColor) params.append('backgroundColor', bgColor);
          if (bgRot) params.append('backgroundRotation', bgRot);
          if (radius) params.set('radius', radius);
          if (rotate) params.set('rotate', rotate);
          if (scale) params.set('scale', scale);
          if (flip) params.set('flip', flip);
          if (clip) params.set('clip', clip);
          if (tx) params.set('translateX', tx);
          if (ty) params.set('translateY', ty);

          if (eyes) params.set('eyes', eyes);
          if (mouth) params.set('mouth', mouth);
          if (eyebrows) params.set('eyebrows', eyebrows);
          if (glasses) {
            params.set('glasses', glasses);
            if (glassesProbability) params.set('glassesProbability', glassesProbability);
          } else {
            // Clear probability control to avoid stale values affecting preview
            const gp = document.getElementById('opt-glassesProbability');
            if (gp) gp.value = '';
          }
          if (earrings) {
            params.set('earrings', earrings);
            if (earringsProbability) params.set('earringsProbability', earringsProbability);
          } else {
            const ep = document.getElementById('opt-earringsProbability');
            if (ep) ep.value = '';
          }
          if (featuresSel){
            const vals = Array.from(featuresSel.selectedOptions).map(o=>o.value).filter(Boolean);
            vals.forEach(v=> params.append('features', v));
            if (vals.length > 0 && featuresProbability) {
              params.set('featuresProbability', featuresProbability);
            } else {
              const fp = document.getElementById('opt-featuresProbability');
              if (fp) fp.value = '';
            }
          }
          if (hair) {
            params.set('hair', hair);
            if (hairColor) params.set('hairColor', hairColor);
            if (hairProbability) params.set('hairProbability', hairProbability);
          } else {
            const hp = document.getElementById('opt-hairProbability');
            if (hp) hp.value = '';
          }
          if (skinColor) params.set('skinColor', skinColor);

          return `${base}?${params.toString()}`;
        }

        function updateAvatarPreview(){
          const url = buildAvatarUrlFromControls();
          window.currentAvatarUrl = url;
          const img = document.getElementById('avatarPreview');
          if (img) img.src = url;
        }

        // Auto-update preview for any control changes within the avatar step
        (function bindAvatarAutoPreview(){
          const scope = document.getElementById('welcome-step3');
          if (!scope || scope.dataset.previewBound === '1') return;
          const cb = (source = 'unknown') => { 
            try { 
              console.log(`Avatar preview update triggered by: ${source}`);
              updateAvatarPreview(); 
            } catch(e) {
              console.error('Preview update failed:', e);
            }
          };
          
          // Listen to changes on all selects and inputs
          scope.addEventListener('change', (e) => {
            if (e.target.matches('select, input[type="radio"], input[type="checkbox"]')) {
              console.log(`Change event on ${e.target.id || e.target.tagName}`);
              cb(`change:${e.target.id || e.target.tagName}`);
            }
          });
          
          scope.addEventListener('input', (e) => {
            if (e.target.matches('select, input[type="range"]')) {
              console.log(`Input event on ${e.target.id || e.target.tagName}`);
              cb(`input:${e.target.id || e.target.tagName}`);
            }
          });
          
          // Also catch clicks on our option buttons (e.g., swatches)
          scope.addEventListener('click', (e) => {
            if ((e.target).closest('.option-btn')) {
              console.log(`Option button clicked: ${e.target.className}`);
              cb('option-button-click');
            }
          });
          
          // Add additional observer for dynamic content changes
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                // Check if any of the added nodes are select elements or contain them
                const addedSelects = Array.from(mutation.addedNodes).filter(node => 
                  node.nodeType === 1 && (node.tagName === 'SELECT' || node.querySelector('select'))
                );
                if (addedSelects.length > 0) {
                  console.log('New select elements detected, rebinding events');
                  // Small delay to ensure elements are fully ready
                  setTimeout(() => {
                    // Trigger a preview update in case default values should be applied
                    cb('dynamic-select-added');
                  }, 100);
                }
              }
            });
          });
          
          observer.observe(scope, { childList: true, subtree: true });
          scope.dataset.previewBound = '1';
        })();

        // Helper to safely set a select's value and fire change (used by AI fill or programmatic updates)
        function setSelectValue(id, val){
          const el = document.getElementById(id);
          if (!el) return;
          el.value = String(val);
          el.dispatchEvent(new Event('change', { bubbles: true }));
        }

        // ---- Skin tone swatches (like hair) ----
        const SKIN_SWATCH_MAP = {
          // Fallback mapping for named tokens -> hex (used if options aren't hex already)
          pale: 'F2D3B1', light: 'EBC7A8', peach: 'F2C1A0', tan: 'D39D6E',
          bronze: 'B97A57', brown: '8D5524', mocha: '6D4C41', dark: '5C3B1E',
          ebony: '3B2F2F'
        };

        function buildSkinSwatches(){
          const select = document.getElementById('opt-skinColor');
          const wrap = document.getElementById('skin-swatch-buttons');
          if (!select || !wrap) return;

          // Avoid rebuilding
          if (wrap.dataset.built === '1') return;

          const options = Array.from(select.options || []).map(o => o.value).filter(Boolean);
          if (!options.length) return; // wait until options are populated

          wrap.innerHTML = '';

          const normalizeHex = (v) => {
            const hex = v.replace('#','');
            if (/^[0-9a-fA-F]{3}$/.test(hex)) return hex; // allow 3-char
            if (/^[0-9a-fA-F]{6}$/.test(hex)) return hex;
            return SKIN_SWATCH_MAP[v] || null;
          };

          options.forEach(v => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'option-btn';
            btn.dataset.value = v;

            const sw = document.createElement('div');
            sw.className = 'option-swatch';
            const hex = normalizeHex(v);
            if (hex) sw.style.background = `#${hex}`;
            else sw.style.background = 'linear-gradient(45deg,#e5e7eb,#cbd5e1)'; // neutral fallback

            btn.appendChild(sw);

            btn.addEventListener('click', () => {
              // visual state
              wrap.querySelectorAll('.option-btn').forEach(b => b.classList.remove('selected'));
              btn.classList.add('selected');
              // set select value so existing code keeps working
              select.value = v;
              // trigger change for any listeners
              select.dispatchEvent(new Event('change', { bubbles: true }));
              updateAvatarPreview();
            });

            if (select.value === v) btn.classList.add('selected');
            wrap.appendChild(btn);
          });

          // Hide the select (already has select-hidden class in HTML), but keep it in DOM for code paths
          select.classList.add('select-hidden');

          // Keep swatch selection synced if value changes elsewhere (AI fill, etc.)
          select.addEventListener('change', () => {
            const val = select.value;
            wrap.querySelectorAll('.option-btn').forEach(b => b.classList.toggle('selected', b.dataset.value === val));
          });

          wrap.dataset.built = '1';
        }

        function ensureSkinSwatchesReady(){
          const select = document.getElementById('opt-skinColor');
          if (!select) return;
          if (select.options && select.options.length > 0) {
            buildSkinSwatches();
            return;
          }
          // Wait until something populates the select
          const mo = new MutationObserver(() => {
            if (select.options.length > 0) { buildSkinSwatches(); mo.disconnect(); }
          });
          mo.observe(select, { childList: true });
        }

        // Kick off once the page has loaded the controls
        ensureSkinSwatchesReady();
        // Force initial preview update for accessory selects once they are populated
        (function ensureAccessoriesReady(){
          const ids = ['opt-glasses','opt-earrings','opt-features'];
          ids.forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;
            
            // Function to bind events to accessory controls
            const bindAccessoryEvents = () => {
              // Make sure change events trigger preview updates
              if (!el.dataset.accessoryEventsBound) {
                el.addEventListener('change', () => {
                  console.log(`${id} changed, updating preview`);
                  updateAvatarPreview();
                  window.avatarDirty = true;
                  const saveMsg = document.getElementById('avatar-save-msg');
                  if (saveMsg) saveMsg.textContent = 'You have unsaved changes — they will be saved when you finish.';
                });
                
                // Also bind to input events for immediate feedback
                el.addEventListener('input', () => {
                  console.log(`${id} input, updating preview`);
                  updateAvatarPreview();
                });
                
                el.dataset.accessoryEventsBound = 'true';
                console.log(`Bound events to ${id}`);
              }
            };
            
            if (el.options && el.options.length > 0) {
              bindAccessoryEvents();
              el.dispatchEvent(new Event('change', { bubbles: true }));
            } else {
              const mo = new MutationObserver(() => {
                if (el.options && el.options.length > 0) {
                  bindAccessoryEvents();
                  el.dispatchEvent(new Event('change', { bubbles: true }));
                  mo.disconnect();
                }
              });
              mo.observe(el, { childList: true });
            }
          });
        })();
        // ---- /Skin tone swatches ----

        function getAiEndpoint(){
          try{
            const loc = window.location;
            if (loc.hostname === '127.0.0.1' || loc.hostname === 'localhost') return 'http://localhost:8787/generate-avatar';
          }catch(_){ }
          return '/api/generate-avatar';
        }

        function collectDropdownOptions(){
          const ids = ['opt-backgroundType','opt-backgroundColor','opt-backgroundRotation','opt-radius','opt-rotate','opt-scale','opt-flip','opt-clip','opt-translateX','opt-translateY','opt-eyes','opt-mouth','opt-eyebrows','opt-glasses','opt-earrings','opt-features','opt-hair','opt-hairColor','opt-skinColor'];
          const out = {};
          for (const id of ids){
            const el = document.getElementById(id);
            if (!el) continue;
            const opts = Array.from(el.options || []).map(o=>o.value).filter(v=>v!=='' && v!=null);
            out[id] = opts;
          }
          // numeric pickers for probs
          out['opt-glassesProbability'] = Array.from(document.getElementById('opt-glassesProbability')?.options||[]).map(o=>Number(o.value)).filter(v=>!isNaN(v));
          out['opt-earringsProbability'] = Array.from(document.getElementById('opt-earringsProbability')?.options||[]).map(o=>Number(o.value)).filter(v=>!isNaN(v));
          out['opt-featuresProbability'] = Array.from(document.getElementById('opt-featuresProbability')?.options||[]).map(o=>Number(o.value)).filter(v=>!isNaN(v));
          out['opt-hairProbability'] = Array.from(document.getElementById('opt-hairProbability')?.options||[]).map(o=>Number(o.value)).filter(v=>!isNaN(v));
          return out;
        }

        async function aiGenerateFromDescription(){
          const prompt = String(document.getElementById('avatarPrompt')?.value||'').trim();
          if (!prompt) throw new Error('Please enter a description first');
          
          if (!globalSupabase) throw new Error('Supabase not initialized');
          
          const nickVal = String(document.getElementById('nickname')?.value || '').trim();
          const seedHint = nickVal || (typeof fullName === 'string' && fullName) || 'User';
          const options = collectDropdownOptions();
          
          // Always use Supabase Edge Function (authenticated and working)
          console.log('Using Supabase Edge Function for AI generation');
          console.log('Generating avatar for description:', prompt);
          
          // Debug: Check if user is logged in
          const { data: { session } } = await globalSupabase.auth.getSession();
          console.log('Current session:', session ? `User: ${session.user.email}` : 'No session');
          
          if (!session || !session.user) {
            throw new Error('You must be logged in to generate avatars. Please refresh and log in again.');
          }
          
          // Build payload
          const payload = { description: prompt, options, seedHint };

          try {
            console.log('Calling Edge Function with payload:', payload);
            console.log('Using Supabase client:', globalSupabase);
            console.log('Session token:', session.access_token ? 'Present' : 'Missing');
            
            const { data, error } = await globalSupabase.functions.invoke('generate-avatar', { body: payload });

            console.log('Supabase Edge Function response:', { data, error });

            if (error) {
              console.error('Edge Function error details:', error);
              console.error('Error type:', typeof error);
              console.error('Error keys:', Object.keys(error));
              console.error('Full error object:', JSON.stringify(error, null, 2));
              
              // Better error handling
              if (error.message) {
                if (error.message.includes('FunctionsHttpError') || error.message.includes('Failed to send')) {
                  // This is likely a network or CORS issue
                  throw new Error('Failed to connect to avatar generation service. Please check your connection and try again.');
                } else if (error.message.includes('Unauthorized') || error.message.includes('authorization')) {
                  throw new Error('Authentication failed. Please refresh and log in again.');
                } else if (error.message.includes('CheckLoopsAI')) {
                  throw new Error('AI service configuration error. Please contact support.');
                } else {
                  throw new Error(`Avatar generation error: ${error.message}`);
                }
              } else if (error.context && error.context.status === 401) {
                throw new Error('Authentication failed. Please refresh and log in again.');
              }
              throw new Error(`AI generation failed: ${JSON.stringify(error)}`);
            }

            if (!data || Object.keys(data).length === 0) {
              throw new Error('No avatar data returned from AI. Please try a different description.');
            }

            console.log('Successfully generated avatar data:', data);
            applyAiResult(data);
            // Preview updated, but not saved until user clicks Continue
            updateAvatarPreview();
            // REMOVED: Auto-save after AI generation - only save when user clicks Continue
            const msg = document.getElementById('avatar-ai-msg');
            if (msg) msg.innerHTML = '✅ Avatar generated successfully. You can fine-tune below or click Continue to save.';
            return data;
          } catch (supabaseError) {
            // Log error for console only
            console.error('Caught error in Edge Function call:', supabaseError);
            console.error('Error stack:', supabaseError.stack);
            
            // Check for specific error patterns
            const errorStr = String(supabaseError);
            const errorMsg = supabaseError.message || errorStr;
            
            if (errorMsg.includes('Failed to connect') || errorMsg.includes('Failed to send')) {
              // Already handled above, just re-throw
              throw supabaseError;
            } else if (errorStr.includes('Authentication') || errorStr.includes('Unauthorized')) {
              throw new Error('Authentication failed. Please refresh the page and log in again.');
            } else if (errorStr.includes('fetch') || errorStr.includes('NetworkError')) {
              throw new Error('Network error. Please check your connection and try again.');
            } else if (errorStr.includes('timeout')) {
              throw new Error('Request timed out. Please try again with a shorter description.');
            } else if (errorStr.includes('CORS')) {
              throw new Error('Connection blocked. Please check if you are logged in properly.');
            }
            
            // If we get here, throw the original error message if it's clear enough
            if (supabaseError.message && supabaseError.message.length < 200) {
              throw supabaseError;
            } else {
              throw new Error('Avatar generation failed. Please try again or contact support.');
            }
          }
        }

        function applyAiResult(data){
          console.log('Applying AI result:', data);
          
          const setVal = (id, val) => {
            const el = document.getElementById(id);
            if (!el) {
              console.warn(`Element not found: ${id}`);
              return;
            }
            el.value = String(val);
            // fire change so preview + any listeners update
            el.dispatchEvent(new Event('change', { bubbles: true }));
            console.log(`Set ${id} = ${val}`);
          };
          
          const maybe = (k) => data[k] !== undefined && data[k] !== null && data[k] !== '';
          
          // Handle seed specially (no visible input)
          if (maybe('seed')) {
            try { window.aiSeed = String(data.seed); } catch(_) {}
            const sEl = document.getElementById('opt-seed');
            if (sEl) sEl.value = String(data.seed);
            console.log(`Set seed = ${data.seed}`);
          }
          
          // Map all the standard fields
          const fieldMappings = new Map([
            ['backgroundType','opt-backgroundType'],
            ['backgroundColor','opt-backgroundColor'],
            ['backgroundRotation','opt-backgroundRotation'],
            ['radius','opt-radius'],
            ['rotate','opt-rotate'],
            ['scale','opt-scale'],
            ['flip','opt-flip'],
            ['clip','opt-clip'],
            ['translateX','opt-translateX'],
            ['translateY','opt-translateY'],
            ['eyes','opt-eyes'],
            ['mouth','opt-mouth'],
            ['eyebrows','opt-eyebrows'],
            ['glasses','opt-glasses'],
            ['glassesProbability','opt-glassesProbability'],
            ['earrings','opt-earrings'],
            ['earringsProbability','opt-earringsProbability'],
            ['featuresProbability','opt-featuresProbability'],
            ['hair','opt-hair'],
            ['hairColor','opt-hairColor'],
            ['hairProbability','opt-hairProbability'],
            ['skinColor','opt-skinColor']
          ]);
          
          for (const [dataKey, elementId] of fieldMappings.entries()) { 
            if (maybe(dataKey)) {
              setVal(elementId, data[dataKey]); 
            }
          }

          // Handle features array (multi-select) separately
          if (Array.isArray(data.features) && data.features.length > 0) {
            const featuresEl = document.getElementById('opt-features');
            if (featuresEl) {
              // First clear all selections
              Array.from(featuresEl.options).forEach(option => {
                option.selected = false;
              });
              // Then select the ones from AI
              Array.from(featuresEl.options).forEach(option => {
                if (data.features.includes(option.value)) {
                  option.selected = true;
                  console.log(`Selected feature: ${option.value}`);
                }
              });
            }
          } else if (maybe('features') && typeof data.features === 'string') {
            // Handle single feature as string
            const featuresEl = document.getElementById('opt-features');
            if (featuresEl) {
              Array.from(featuresEl.options).forEach(option => {
                option.selected = (option.value === data.features);
              });
              console.log(`Selected single feature: ${data.features}`);
            }
          }

          // Log what we successfully applied
          const appliedFields = [];
          for (const [dataKey] of fieldMappings.entries()) {
            if (maybe(dataKey)) appliedFields.push(dataKey);
          }
          if (Array.isArray(data.features) || maybe('features')) appliedFields.push('features');
          console.log(`Applied fields: ${appliedFields.join(', ')}`);
          
          // Update the avatar preview with new settings
          updateAvatarPreview();
          
          // Show success feedback
          const msg = document.getElementById('avatar-ai-msg');
          if (msg) {
            const probFields = [];
            if (maybe('hairProbability')) probFields.push('hair probability');
            if (maybe('featuresProbability')) probFields.push('features probability');
            if (maybe('glassesProbability')) probFields.push('glasses probability');
            if (maybe('earringsProbability')) probFields.push('earrings probability');
            
            let feedbackText = `Applied! Generated ${appliedFields.length} avatar settings.`;
            if (probFields.length > 0) {
              feedbackText += ` Including ${probFields.join(', ')}.`;
            }
            feedbackText += ' You can fine-tune with the dropdowns below.';
            msg.textContent = feedbackText;
          }
          
          // No manual save prompt for AI-applied results; we will auto-save elsewhere.
        }

        async function initAvatarBuilder(fullName){
          // Fill dropdowns
          const seedEl = document.getElementById('opt-seed');
          const nickVal = String(document.getElementById('nickname')?.value || '').trim();
          if (seedEl) seedEl.value = nickVal || fullName || 'User';

          const fillOpts = (el, arr, withBlank=false) => {
            el.innerHTML = '';
            if (withBlank) el.appendChild(new Option('Default',''));
            for(const v of arr){ el.appendChild(new Option(String(v), String(v))); }
          };

          // Human‑readable labels for avatar options - analyzed with OpenAI Vision
          const eyeLabels = {
            variant01: 'Eyes: Curious',
            variant02: 'Eyes: Observant',
            variant03: 'Eyes: Inquisitive',
            variant04: 'Eyes: Unimpressed',
            variant05: 'Eyes: Pondering',
            variant06: 'Eyes: Doubtful',
            variant07: 'Eyes: Dispassionate',
            variant08: 'Eyes: Wide-eyed',
            variant09: 'Eyes: Quizzical',
            variant10: 'Eyes: Skeptical',
            variant11: 'Eyes: Mildly Amused',
            variant12: 'Eyes: Mischievous',
            variant13: 'Eyes: Sardonic',
            variant14: 'Eyes: Cynical',
            variant15: 'Eyes: Softly Sorrowful',
            variant16: 'Eyes: Slightly Disenchanted',
            variant17: 'Eyes: Unimpressed gaze',
            variant18: 'Eyes: Nonchalant',
            variant19: 'Eyes: Calmly Satisfied',
            variant20: 'Eyes: Subdued Glow',
            variant21: 'Eyes: Winking Playfulness',
            variant22: 'Eyes: Playfully Squinting',
            variant23: 'Eyes: Slightly Confounded',
            variant24: 'Eyes: Blankly Engaged',
            variant25: 'Eyes: Contemplative',
            variant26: 'Eyes: Slightly Bewildered'
          };
          const mouthLabels = {
            variant01: 'Mouth: Cheerful curve',
            variant02: 'Mouth: Subdued smirk',
            variant03: 'Mouth: Awestruck pout',
            variant04: 'Mouth: Pensive line',
            variant05: 'Mouth: Beaming smile',
            variant06: 'Mouth: Delicate crease',
            variant07: 'Mouth: Shocked oval',
            variant08: 'Mouth: Slight line',
            variant09: 'Mouth: Straight line',
            variant10: 'Mouth: Puffed pout',
            variant11: 'Mouth: Tensed line',
            variant12: 'Mouth: Playful protrusion',
            variant13: 'Mouth: Distorted surprise',
            variant14: 'Mouth: Awkward oval',
            variant15: 'Mouth: Spacious oval',
            variant16: 'Mouth: Playful tongue-out',
            variant17: 'Mouth: Subtle expression',
            variant18: 'Mouth: O-shaped surprise',
            variant19: 'Mouth: Curious line',
            variant20: 'Mouth: Pouty hint',
            variant21: 'Mouth: Tiny tease',
            variant22: 'Mouth: Mischievous twist',
            variant23: 'Mouth: Grinning gap',
            variant24: 'Mouth: Hearted surprise',
            variant25: 'Mouth: Gleeful grin',
            variant26: 'Mouth: Joyful arch',
            variant27: 'Mouth: Excited line',
            variant28: 'Mouth: Joyful beam',
            variant29: 'Mouth: Quirky twist',
            variant30: 'Mouth: Joyful triangle'
          };
          const browLabels = {
            variant01: 'Brows: Boldly Angled',
            variant02: 'Brows: Fiercely Slanted',
            variant03: 'Brows: Subtle Arch',
            variant04: 'Brows: Slightly Curved',
            variant05: 'Brows: Quirky Flick',
            variant06: 'Brows: Playfully Raised',
            variant07: 'Brows: Subdued Lift',
            variant08: 'Brows: Mildly Furrowed',
            variant09: 'Brows: Mildly Arched',
            variant10: 'Brows: Gently Straightened',
            variant11: 'Brows: Slightly Drooped',
            variant12: 'Brows: Softly Straightened',
            variant13: 'Brows: Subtly Defined',
            variant14: 'Brows: Lightly Tapered',
            variant15: 'Brows: Playfully Asymmetrical'
          };
          const glassesLabels = {
            '': 'None',
            variant01: 'Glasses: Round',
            variant02: 'Glasses: Square',
            variant03: 'Glasses: Thin',
            variant04: 'Glasses: Thick',
            variant05: 'Glasses: Cat‑eye'
          };
          const earringsLabels = {
            '': 'None',
            variant01: 'Earrings: Studs',
            variant02: 'Earrings: Hoops',
            variant03: 'Earrings: Drops',
            variant04: 'Earrings: Small Hoops',
            variant05: 'Earrings: Bars',
            variant06: 'Earrings: Stars'
          };
          const hairColorNames = {
            '0e0e0e': 'Black',
            'e5d7a3': 'Blonde',
            '9e5622': 'Brown',
            '763900': 'Dark Brown',
            'cb6820': 'Red',
            'ac6511': 'Copper',
            'b9a05f': 'Sandy',
            '796a45': 'Ash Brown',
            '6a4e35': 'Chestnut',
            '562306': 'Dark Chestnut',
            'afafaf': 'Grey',
            '3eac2c': 'Green',
            '85c2c6': 'Teal',
            'dba3be': 'Pink',
            '592454': 'Plum'
          };
          const skinColorNames = {
            'f2d3b1': 'Fair',
            'ecad80': 'Tan',
            '9e5622': 'Brown',
            '763900': 'Dark Brown'
          };

          function labelFromVariant(prefix, v, map){
            if (map && map[v]) return map[v];
            const sv = String(v);
            if (sv.startsWith('variant')) {
              const n = parseInt(sv.slice(7), 10);
              const num = isNaN(n) ? sv.replace('variant','') : n;
              return `${prefix} Style ${num}`; // e.g., "Mouth Style 9"
            }
            return `${prefix} ${sv}`;
          }
          const hairStyleNames = {
            short01: 'Short: Fluffy layers',
            short02: 'Short: Playful bangs',
            short03: 'Short: Bouncy curls',
            short04: 'Short: Tapered edges',
            short05: 'Short: Top Knot',
            short06: 'Short: Asymmetrical swoop',
            short07: 'Short: Whimsical waves',
            short08: 'Short: Spiraled tufts',
            short09: 'Short: Flared spikes',
            short10: 'Short: Defined bob',
            short11: 'Short: Sleek pompadour',
            short12: 'Short: Bold streak',
            short13: 'Short: Sleek crop',
            short14: 'Short: Bold quiff',
            short15: 'Short: Spiky flair',
            short16: 'Short: Wild spikes',
            short17: 'Short: Textured tufts',
            short18: 'Short: Quirky tufts',
            short19: 'Short: Smoothly cropped',
            long01: 'Long: Sleek sweep',
            long02: 'Long: Playful tousle',
            long03: 'Long: Floral crown',
            long04: 'Long: Angular strands',
            long05: 'Long: Softly rounded',
            long06: 'Long: Lush tendrils',
            long07: 'Long: Choppy fringes',
            long08: 'Long: Floral fringe',
            long09: 'Long: Flowing layers',
            long10: 'Long: Spirited ponytail',
            long11: 'Long: Playful top-knot',
            long12: 'Long: Subtle bob',
            long13: 'Long: Twisted buns',
            long14: 'Long: Double ponytails',
            long15: 'Long: Playful pigtails',
            long16: 'Long: Braided charm',
            long17: 'Long: Playful curls',
            long18: 'Long: Charming waves',
            long19: 'Long: Sleek ponytail',
            long20: 'Long: Angular sweep',
            long21: 'Long: Curved strands',
            long22: 'Long: Lively volume',
            long23: 'Long: Playful buns',
            long24: 'Long: Lively bounce',
            long25: 'Long: Sleek asymmetry',
            long26: 'Long: Vibrant fringes'
          };
          
          function hairLabel(key){
            return hairStyleNames[key] || String(key);
          }
          function fillOptsLabeled(el, values, labeler, withBlank=false){
            el.innerHTML = '';
            if (withBlank) el.appendChild(new Option('Default',''));
            for (const v of values){
              const label = labeler(v);
              const opt = new Option(label, String(v));
              opt.title = label;
              el.appendChild(opt);
            }
          }

          // Fetch optional DB labels so you can manage names without code changes
          async function fetchLabelMap(){
            try {
              const { data, error } = await supabase
                .from('avatar_option_labels')
                .select('option_id,value_key,label');
              if (error || !Array.isArray(data)) return {};
              const map = {};
              for (const r of data) {
                if (!map[r.option_id]) map[r.option_id] = {};
                map[r.option_id][r.value_key] = r.label;
              }
              return map;
            } catch(_) { return {}; }
          }

          const dbLabels = await fetchLabelMap();
          const labelFor = (optId, value, fallback) => {
            const lab = dbLabels?.[optId]?.[String(value)];
            return lab || fallback;
          };

          fillOpts(document.getElementById('opt-backgroundRotation'), rangeArr(0,360,15), true);
          fillOpts(document.getElementById('opt-radius'), rangeArr(0,50,5), true);
          fillOpts(document.getElementById('opt-rotate'), rangeArr(0,360,15), true);
          fillOpts(document.getElementById('opt-translateX'), rangeArr(-50,50,5), true);
          fillOpts(document.getElementById('opt-translateY'), rangeArr(-50,50,5), true);

          // Adventurer variants
          const eyes = Array.from({length:26}, (_,i)=>`variant${pad2(i+1)}`);
          const mouths = Array.from({length:30}, (_,i)=>`variant${pad2(i+1)}`);
          const brows = Array.from({length:15}, (_,i)=>`variant${pad2(i+1)}`);
          const glasses = Array.from({length:5},  (_,i)=>`variant${pad2(i+1)}`);
          const earrings = Array.from({length:6},  (_,i)=>`variant${pad2(i+1)}`);
          const features = ['mustache','blush','birthmark','freckles'];
          const featureLabels = {
            'mustache': 'Facial Hair',
            'blush': 'Rosy Cheeks', 
            'birthmark': 'Beauty Mark',
            'freckles': 'Freckles'
          };
          const hair = [
            ...Array.from({length:19}, (_,i)=>`short${pad2(i+1)}`),
            ...Array.from({length:26}, (_,i)=>`long${pad2(i+1)}`)
          ];
          // Expanded hair color palette to include browns returned by AI
          const hairColors = ['ac6511','cb6820','ab2a18','e5d7a3','b9a05f','796a45','6a4e35','562306','9e5622','763900','0e0e0e','afafaf','3eac2c','85c2c6','dba3be','592454'];
          const skinColors = ['f2d3b1','ecad80','9e5622','763900'];

          fillOptsLabeled(document.getElementById('opt-eyes'), eyes, v=>labelFor('opt-eyes', v, labelFromVariant('Eyes', v, eyeLabels)), true);
          fillOptsLabeled(document.getElementById('opt-mouth'), mouths, v=>labelFor('opt-mouth', v, labelFromVariant('Mouth', v, mouthLabels)), true);
          fillOptsLabeled(document.getElementById('opt-eyebrows'), brows, v=>labelFor('opt-eyebrows', v, labelFromVariant('Brows', v, browLabels)), true);
          fillOptsLabeled(document.getElementById('opt-glasses'), ['','variant01','variant02','variant03','variant04','variant05'], v=>labelFor('opt-glasses', v, (glassesLabels[v] || labelFromVariant('Glasses', v, {}))), false);
          fillOpts(document.getElementById('opt-glassesProbability'), rangeArr(0,100,10), true);
          fillOptsLabeled(document.getElementById('opt-earrings'), ['','variant01','variant02','variant03','variant04','variant05','variant06'], v=>labelFor('opt-earrings', v, (earringsLabels[v] || labelFromVariant('Earrings', v, {}))), false);
          fillOpts(document.getElementById('opt-earringsProbability'), rangeArr(0,100,10), true);
          // features (multi-select)
          const featuresEl = document.getElementById('opt-features');
          if (featuresEl){
            featuresEl.innerHTML = '';
            for (const v of features){ 
              const label = featureLabels[v] || v;
              featuresEl.appendChild(new Option(label, v)); 
            }
          }
          fillOpts(document.getElementById('opt-featuresProbability'), rangeArr(0,100,5), true);
          fillOptsLabeled(document.getElementById('opt-hair'), [''].concat(hair), v=> labelFor('opt-hair', v, (v ? hairLabel(v) : 'Default')), false);
          fillOptsLabeled(document.getElementById('opt-hairColor'), [''].concat(hairColors), hex => labelFor('opt-hairColor', hex, (hex ? ((hairColorNames[hex] ? `${hairColorNames[hex]} (${hex})` : hex)) : 'Default')), false);
          fillOpts(document.getElementById('opt-hairProbability'), rangeArr(0,100,10), true);
          fillOptsLabeled(document.getElementById('opt-skinColor'), [''].concat(skinColors), hex => labelFor('opt-skinColor', hex, (hex ? ((skinColorNames[hex] ? `${skinColorNames[hex]} (${hex})` : hex)) : 'Default')), false);

          // Bind changes
          const ids = [
            'opt-backgroundType','opt-backgroundColor','opt-backgroundRotation','opt-radius','opt-rotate','opt-scale','opt-flip','opt-clip','opt-translateX','opt-translateY','opt-eyes','opt-mouth','opt-eyebrows','opt-glasses','opt-glassesProbability','opt-earrings','opt-earringsProbability','opt-featuresProbability','opt-hair','opt-hairColor','opt-hairProbability','opt-skinColor'
          ];
          
          // Function to bind events to a control
          const bindControlEvents = (id) => {
            const el = document.getElementById(id);
            if (el && !el.dataset.bound) { 
              // Bind both input and change events for maximum compatibility
              el.addEventListener('input', () => {
                console.log(`Input event on ${id}, updating preview`);
                updateAvatarPreview();
                // mark that avatar has unsaved manual changes
                window.avatarDirty = true;
                const saveMsg = document.getElementById('avatar-save-msg');
                if (saveMsg) saveMsg.textContent = 'You have unsaved changes — they will be saved when you finish.';
              });
              
              el.addEventListener('change', () => {
                console.log(`Change event on ${id}, updating preview`);
                updateAvatarPreview();
                window.avatarDirty = true;
                const saveMsg = document.getElementById('avatar-save-msg');
                if (saveMsg) saveMsg.textContent = 'You have unsaved changes — they will be saved when you finish.';
              });
              
              el.dataset.bound = '1'; 
              console.log(`Bound events to control: ${id}`);
            }
          };
          
          // Initial binding attempt
          ids.forEach(bindControlEvents);
          
          // Delayed binding for accessory controls that might be populated later
          setTimeout(() => {
            const accessoryIds = ['opt-glasses', 'opt-earrings', 'opt-features'];
            accessoryIds.forEach(id => {
              const el = document.getElementById(id);
              if (el && !el.dataset.bound && el.options && el.options.length > 0) {
                console.log(`Late binding for ${id} with ${el.options.length} options`);
                bindControlEvents(id);
              }
            });

            // Auto-manage probabilities for accessories to reflect immediately
            const autoProb = (styleId, probId) => {
              const styleEl = document.getElementById(styleId);
              const probEl = document.getElementById(probId);
              if (!styleEl || !probEl) return;
              if (!styleEl.dataset.probAutoBound) {
                styleEl.addEventListener('change', () => {
                  const val = String(styleEl.value || '').trim();
                  if (val) {
                    // If a style is selected and prob empty, set to 100
                    if (!String(probEl.value || '').trim()) probEl.value = '100';
                  } else {
                    // If cleared, blank out probability to avoid stale param
                    probEl.value = '';
                  }
                  updateAvatarPreview();
                });
                styleEl.dataset.probAutoBound = '1';
              }
            };
            autoProb('opt-glasses', 'opt-glassesProbability');
            autoProb('opt-earrings', 'opt-earringsProbability');
            // For features, if any selected and prob empty, set to 100; else clear
            const featsEl = document.getElementById('opt-features');
            const featsProbEl = document.getElementById('opt-featuresProbability');
            if (featsEl && featsProbEl && !featsEl.dataset.probAutoBound) {
              featsEl.addEventListener('change', () => {
                const any = Array.from(featsEl.selectedOptions).some(o => !!o.value);
                if (any && !String(featsProbEl.value || '').trim()) featsProbEl.value = '100';
                if (!any) featsProbEl.value = '';
                updateAvatarPreview();
              });
              featsEl.dataset.probAutoBound = '1';
            }
          }, 500); // Wait 500ms for async population
          // features (multi-select)
          const featuresMulti = document.getElementById('opt-features');
          if (featuresMulti && !featuresMulti.dataset.bound){ 
            featuresMulti.addEventListener('change', () => {
              updateAvatarPreview();
              window.avatarDirty = true;
              const saveMsg = document.getElementById('avatar-save-msg');
              if (saveMsg) saveMsg.textContent = 'You have unsaved changes — they will be saved when you finish.';
            }); 
            featuresMulti.dataset.bound='1'; 
          }

          // ---------- New: render friendly option buttons for several selects ----------
          const makeOptionButtons = (selectId, opts, renderFn, hideSelect = false) => {
            const sel = document.getElementById(selectId);
            if (!sel) return null;
            // create container after select
            const container = document.createElement('div');
            container.className = 'option-buttons';
            // optionally hide the native select (keep it in DOM for state)
            if (hideSelect) sel.classList.add('select-hidden');
            // For each option create a button
            const values = opts || Array.from(sel.options || []).map(o=> ({ v: o.value, t: o.text }));
            // If opts is provided as array of values, normalize
            const norm = values.map(x => (typeof x === 'string' || typeof x === 'number') ? { v: String(x), t: String(x) } : x);
            norm.forEach(item => {
              // skip empty values (use default behavior)
              if (!item.v || item.v === '') return;
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'option-btn';
              btn.dataset.value = item.v;
              // render content via renderFn or fallback
              if (renderFn) btn.appendChild(renderFn(item)); else btn.textContent = item.t || item.v;
              // click behavior: select corresponding option in native select and trigger input
              btn.addEventListener('click', (e)=>{
                e.preventDefault();
                // handle single vs multi
                if (sel.multiple){
                  const opt = Array.from(sel.options).find(o=>String(o.value)===String(item.v));
                  if (opt) opt.selected = !opt.selected;
                  btn.classList.toggle('selected', !!opt && opt.selected);
                } else {
                  // clear other buttons
                  container.querySelectorAll('.option-btn').forEach(b=> b.classList.remove('selected'));
                  btn.classList.add('selected');
                  // set select value
                  sel.value = item.v;
                }
                // dispatch input event
                sel.dispatchEvent(new Event('input', { bubbles:true }));
                sel.dispatchEvent(new Event('change', { bubbles:true }));
              });
              container.appendChild(btn);
            });
            // insert container after select
            sel.parentNode.insertBefore(container, sel.nextSibling);

            // Initialize selected state from select value(s)
            const syncFromSelect = () => {
              const vals = sel.multiple ? Array.from(sel.selectedOptions).map(o=>String(o.value)) : [String(sel.value)];
              container.querySelectorAll('.option-btn').forEach(b=>{
                const v = String(b.dataset.value);
                b.classList.toggle('selected', vals.includes(v));
              });
            };
            // initial sync
            syncFromSelect();
            // keep in sync if select changes externally
            sel.addEventListener('change', syncFromSelect);
            return container;
          };

          // Helper renderers
          const swatchRenderer = (hex) => {
            const span = document.createElement('span');
            span.className = 'option-swatch';
            span.style.background = `#${hex.v}`;
            span.title = hex.t || hex.v;
            return span;
          };
          const textRenderer = (item) => {
            const span = document.createElement('span');
            span.textContent = item.t || item.v;
            return span;
          };

          // Only render hair color as swatch buttons; keep other options as dropdowns
          try {
            const hairColorOpts = Array.from(document.getElementById('opt-hairColor')?.options||[]).map(o=> ({ v:o.value, t:o.text }));
            makeOptionButtons('opt-hairColor', hairColorOpts, swatchRenderer, true);
          } catch (e) { console.warn('option button render failed', e); }

          // --------------------------------------------------------------------------------

          // Function to mark manual changes and show save button
          function markManualChange() {
            // deprecated: kept for backwards compatibility if other code calls it
            window.avatarDirty = true;
            const saveMsg = document.getElementById('avatar-save-msg');
            if (saveMsg) saveMsg.textContent = 'You have unsaved changes — they will be saved when you finish.';
          }

          // Randomize/reset
          const rnd = document.getElementById('avatar-randomize');
          if (rnd && !rnd.dataset.bound){ rnd.addEventListener('click', async ()=>{
            const seeds = ['Nova','Ziggy','Aria','Kai','Milo','Ivy','Atlas','Sage','Skye','Orion','Zoe','Finn','Quinn','Remy'];
            const seed = seeds[Math.floor(Math.random()*seeds.length)] + Math.floor(Math.random()*100);
            try { window.aiSeed = seed; } catch(_) {}
            if (seedEl) seedEl.value = seed;
            const pick = (arr)=> arr[Math.floor(Math.random()*arr.length)];
            document.getElementById('opt-eyes').value = pick(eyes);
            document.getElementById('opt-mouth').value = pick(mouths);
            document.getElementById('opt-eyebrows').value = pick(brows);
            document.getElementById('opt-glasses').value = pick(['','variant01','variant02','variant03','variant04','variant05']);
            document.getElementById('opt-glassesProbability').value = pick(rangeArr(0,100,10));
            document.getElementById('opt-earrings').value = pick(['','variant01','variant02','variant03','variant04','variant05','variant06']);
            document.getElementById('opt-earringsProbability').value = pick(rangeArr(0,100,10));
            document.getElementById('opt-hair').value = pick(hair);
            document.getElementById('opt-hairColor').value = pick(hairColors);
            document.getElementById('opt-hairProbability').value = pick(rangeArr(0,100,10));
            document.getElementById('opt-skinColor').value = pick(skinColors);
            const fEl = document.getElementById('opt-features');
            for (const o of Array.from(fEl.options)) o.selected = false;
            // randomly pick up to 2 features
            const pool = [...features];
            for (let i=0;i<Math.floor(Math.random()*3);i++){
              const idx = Math.floor(Math.random()*pool.length);
              const val = pool.splice(idx,1)[0];
              const opt = Array.from(fEl.options).find(o=>o.value===val); if (opt) opt.selected = true;
            }
            updateAvatarPreview();
            markManualChange(); // Show that changes were made

            // REMOVED: Auto-save after randomization - only save when user clicks Continue
            const saveMsg = document.getElementById('avatar-save-msg');
            if (saveMsg) {
              saveMsg.textContent = '✅ Avatar randomized! Click Continue to save.';
            }
          }); rnd.dataset.bound='1'; }

          // Manual save button
          const manualSaveBtn = document.getElementById('avatar-save-manual');
          if (manualSaveBtn && !manualSaveBtn.dataset.bound) {
            manualSaveBtn.addEventListener('click', async () => {
              const saveMsg = document.getElementById('avatar-save-msg');
              try {
                const avatarUrl = buildAvatarUrlFromControls();
                console.log('Manual save: Avatar URL:', avatarUrl);

                if (saveMsg) saveMsg.textContent = 'Saving avatar...';

                const saveFunction = (typeof saveAvatarToSupabase !== 'undefined') ? saveAvatarToSupabase : window.saveAvatarToSupabase;
                if (saveFunction) {
                  const result = await saveFunction(avatarUrl);
                  if (result !== false) {
                    if (saveMsg) saveMsg.textContent = '✅ Avatar saved successfully! You can now see it on the homepage.';
                    window.avatarDirty = false;

                    // Force refresh the homepage avatar by clearing any cached data
                    try {
                      // Update the session to get fresh data next time
                      const { data: { user: refreshedUser } } = await supabase.auth.getUser();
                      console.log('User session refreshed after avatar save');
                    } catch(e) {
                      console.warn('Could not refresh user session:', e);
                    }
                  } else {
                    if (saveMsg) saveMsg.textContent = '❌ Failed to save avatar';
                  }
                } else {
                  console.error('saveAvatarToSupabase function not found');
                  if (saveMsg) saveMsg.textContent = '❌ Save function not available';
                }
              } catch (error) {
                console.error('Manual save error:', error);
                if (saveMsg) saveMsg.textContent = '❌ Error: ' + error.message;
              }
            });
            manualSaveBtn.dataset.bound = '1';
          }

          // Save helper used by both AI auto-save and finish/save flow
          // CONSOLIDATED Avatar Save Function - saves to all necessary tables
          async function saveAvatarToSupabase(avatarUrl){
            const saveMsg = document.getElementById('avatar-save-msg');
            console.log('[saveAvatarToSupabase] Starting save with URL:', avatarUrl);
            try {
              const nickVal = String(document.getElementById('nickname')?.value || '').trim() || null;
              const displayName = nickVal || fullName || user?.email?.split('@')[0] || 'Staff';
              if (saveMsg) { saveMsg.textContent = 'Saving avatar...'; }
              console.log('[saveAvatarToSupabase] Nickname:', nickVal, 'Display name:', displayName);

              // Save avatar URL to user metadata
              await supabase.auth.updateUser({
                data: {
                  avatar_url: avatarUrl,
                  nickname: nickVal,
                  role_detail: window.selectedRole || user?.raw_user_meta_data?.role_detail || null,
                  team_id: window.selectedTeamId || null,
                  team_name: window.selectedTeamName || null
                }
              });

              // Save to master_users table (primary source of truth)
              try {
                // Get the original access_type from user metadata (set during invitation)
                const originalRole = user?.user_metadata?.role ||
                                         user?.raw_user_meta_data?.role ||
                                         user?.app_metadata?.role ||
                                         'Staff';

                // Map roles to valid access_types
                let accessType = 'staff'; // Default to staff
                if (originalRole?.toLowerCase() === 'admin') {
                  accessType = 'admin';
                } else if (originalRole?.toLowerCase() === 'owner') {
                  accessType = 'owner';
                }
                // GP role maps to 'staff' access_type with role_detail='GP'

                // Get the original full_name from invitation data
                const originalFullName = user?.user_metadata?.full_name ||
                                       user?.raw_user_meta_data?.full_name ||
                                       fullName || displayName;

                const masterData = {
                  auth_user_id: user.id,
                  email: user.email,
                  avatar_url: avatarUrl,
                  nickname: nickVal,
                  full_name: originalFullName,  // Use original full_name from invitation
                  role_detail: window.selectedRole || user?.raw_user_meta_data?.role_detail || null,
                  access_type: accessType,  // Use properly mapped access_type
                  site_id: siteId,
                  team_id: window.selectedTeamId || null,
                  team_name: window.selectedTeamName || null,
                  updated_at: new Date().toISOString()
                };

                console.log('[saveAvatarToSupabase] Checking for existing master_users record');

                // Check if record exists first (include access_type so we can preserve it)
                const { data: existingRecord, error: checkErr } = await supabase
                  .from('master_users')
                  .select('id, access_type')
                  .eq('auth_user_id', user.id)
                  .eq('site_id', siteId || 1)
                  .maybeSingle();

                let masterResult, masterErr;

                if (existingRecord) {
                  // Preserve any existing access_type to avoid downgrading admins
                  if (existingRecord.access_type) {
                    masterData.access_type = existingRecord.access_type;
                    console.log('[saveAvatarToSupabase] Preserving existing access_type:', existingRecord.access_type);
                  } else {
                    // Fallback to computed accessType if no existing value
                    masterData.access_type = accessType;
                    console.log('[saveAvatarToSupabase] No existing access_type found; using computed:', accessType);
                  }

                  // Update existing record
                  console.log('[saveAvatarToSupabase] Updating existing master_users record');
                  const { data, error } = await supabase
                    .from('master_users')
                    .update(masterData)
                    .eq('auth_user_id', user.id)
                    .eq('site_id', siteId || 1)
                    .select();
                  masterResult = data;
                  masterErr = error;
                } else {
                  // Insert new record
                  console.log('[saveAvatarToSupabase] Inserting new master_users record');
                  masterData.access_type = accessType; // set access_type for new records
                  masterData.created_at = new Date().toISOString();
                  const { data, error } = await supabase
                    .from('master_users')
                    .insert(masterData)
                    .select();
                  masterResult = data;
                  masterErr = error;
                }

                if (masterErr) {
                  console.error('[saveAvatarToSupabase] Master users update error:', masterErr);
                  // Fall back to profiles table if master_users doesn't exist
                  const userRole = window.selectedRole ? window.selectedRole.toLowerCase() : 'staff';
                  let normalizedRole = 'staff';
                  if (userRole === 'admin') {
                    normalizedRole = 'admin';
                  }

                  const profileData = {
                    user_id: user.id,
                    avatar_url: avatarUrl,
                    nickname: nickVal,
                    full_name: fullName || displayName,
                    role: normalizedRole
                  };
                  if (siteId) profileData.site_id = siteId;

                  const { data: profileResult, error: profileErr } = await supabase
                    .from('profiles')
                    .upsert(profileData, {
                      onConflict: 'user_id',
                      ignoreDuplicates: false
                    })
                    .select();

                  if (profileErr) {
                    console.error('[saveAvatarToSupabase] Profile update error:', profileErr);
                    throw profileErr;
                  } else {
                    console.log('[saveAvatarToSupabase] Profile updated successfully:', profileResult);
                  }
                } else {
                  console.log('[saveAvatarToSupabase] Master users updated successfully:', masterResult);
                }
                window.currentSavedAvatarUrl = avatarUrl; // Track that avatar was saved
              } catch (e) {
                console.error('[saveAvatarToSupabase] Save exception:', e);
                throw e; // Re-throw to handle upstream
              }

              // staff_app_welcome removed - avatar is saved to master_users above

              // Update 1_staff_holiday_profiles with avatar and latest info
              try {
                // First check if profile exists
                const { data: existingProfile } = await supabase
                  .from('1_staff_holiday_profiles')
                  .select('id')
                  .eq('email', user.email)
                  .maybeSingle();

                if (existingProfile) {
                  // Update existing profile with avatar
                  await supabase
                    .from('1_staff_holiday_profiles')
                    .update({
                      avatar_url: avatarUrl,
                      role: window.selectedRole || user?.raw_user_meta_data?.role || 'Staff',
                      team_name: window.selectedTeamName || null,
                      updated_at: new Date().toISOString()
                    })
                    .eq('id', existingProfile.id);
                }
              } catch (e) {
                console.warn('Holiday profile avatar update error:', e);
              }

              window.currentSavedAvatarUrl = avatarUrl;
              window.avatarDirty = false;
              if (saveMsg) saveMsg.innerHTML = '✅ Avatar saved successfully!';
              return true;
            } catch (e) {
              console.error('Save avatar error:', e);
              if (saveMsg) saveMsg.innerHTML = `❌ Save failed: ${e.message || e}`;
              return false;
            }
          }
          // Expose globally so other handlers (e.g., AI autosave) can call it safely
          try { window.saveAvatarToSupabase = saveAvatarToSupabase; } catch(_) {}

          // Ensure initial dirty state
          window.avatarDirty = false;

          // Back button - now goes back to step1
          const back = document.getElementById('back-to-step1');
          if (back && !back.dataset.bound){ back.addEventListener('click', ()=>{
            document.getElementById('welcome-step3').style.display = 'none';
            document.getElementById('welcome-step1').style.display = '';
          }); back.dataset.bound='1'; }

          // AI Generate button
          const aiBtn = document.getElementById('avatar-ai-generate');
          if (aiBtn && !aiBtn.dataset.bound){ aiBtn.addEventListener('click', async ()=>{
            const msg = document.getElementById('avatar-ai-msg');
            const originalText = msg.textContent;
            
            // Validate description input
            const prompt = String(document.getElementById('avatarPrompt')?.value||'').trim();
            if (!prompt) {
              msg.textContent = '⚠️ Please enter a description first (e.g., "friendly nurse with brown hair")';
              return;
            }
            
            msg.innerHTML = '🤖 AI is generating your avatar... <span style="opacity:0.7">(this may take a few seconds)</span>';
            aiBtn.disabled = true;
            aiBtn.textContent = 'Generating...';
            
            try{
              const result = await aiGenerateFromDescription();
              msg.innerHTML = `✅ Success! Adjust with settings below or click Continue to save.`;
              
              // Auto-focus on preview to draw attention to the result
              const preview = document.getElementById('avatarPreview');
              if (preview) {
                preview.style.transform = 'scale(1.05)';
                setTimeout(() => {
                  preview.style.transform = 'scale(1)';
                  preview.style.transition = 'transform 0.3s ease';
                }, 300);
              }
              
            }catch(e){
              console.error('AI generation error:', e);
              
              // Provide helpful error messages
              let errorMsg = '❌ ';
              if (e.message.includes('Authentication') || e.message.includes('Unauthorized')) {
                errorMsg += 'Please refresh the page and log in again.';
              } else if (e.message.includes('description')) {
                errorMsg += 'Please try a more detailed description.';
              } else if (e.message.includes('Network') || e.message.includes('fetch')) {
                errorMsg += 'Network error. Please check your connection.';
              } else {
                errorMsg += `Generation failed: ${e.message}`;
              }
              
              msg.innerHTML = `${errorMsg} <button onclick="this.parentElement.textContent='${originalText}'" style="margin-left:8px;padding:2px 6px;font-size:11px;border:1px solid #ccc;border-radius:4px;background:#fff;cursor:pointer;">Dismiss</button>`;
            } finally {
              aiBtn.disabled = false;
              aiBtn.textContent = 'Generate with AI';
            }
          }); aiBtn.dataset.bound='1'; }

          // Finish Setup button (skip working hours entirely)
          const finish = document.getElementById('finish-avatar-btn');
          if (finish && !finish.dataset.bound){ finish.addEventListener('click', async ()=>{
            const fm = document.getElementById('finish-avatar-msg');
            fm.textContent = '';

            // Determine current avatar URL
            const avatar = window.currentSavedAvatarUrl || window.currentAvatarUrl || buildAvatarUrlFromControls();

            // If there are unsaved manual changes or avatar not saved yet, save first
            if (window.avatarDirty || !window.currentSavedAvatarUrl) {
              try{
                if (fm) fm.textContent = 'Saving your avatar…';
                const ok = await saveAvatarToSupabase(avatar);
                if (!ok) {
                  console.warn('Avatar save returned false; continuing to working hours');
                  if (fm) fm.innerHTML = '⚠️ Could not fully save your avatar. Continuing to working hours…';
                  // Do NOT return here; continue to working hours so the user can finish setup
                } else {
                  if (fm) fm.textContent = 'Avatar saved.';
                }
              } catch (e) {
                console.warn('finish save failed (exception), continuing', e);
                if (fm) fm.innerHTML = '⚠️ Could not save your avatar. Continuing to working hours…';
                // continue despite errors
              }
            }

            // Save avatar and profile data
            const teamIdNum = (window.selectedTeamId ?? null);
            const role = (window.selectedRole || 'staff');
            const nicknameValue = document.getElementById('nickname')?.value?.trim() || user?.email?.split('@')[0] || 'Staff';
            let saveErrors = [];

            // 1. staff_app_welcome removed - using master_users as primary storage

            // 2. Save/update profiles table (for compatibility)
            try {
              const profileData = {
                user_id: user.id,
                site_id: siteId,
                full_name: user?.raw_user_meta_data?.full_name || user?.email?.split('@')[0] || 'Staff',
                nickname: nicknameValue,
                role: (role || 'staff').toLowerCase(),  // Ensure valid role for constraint (lowercase)
                avatar_url: avatar,
                onboarding_complete: true
              };

              console.log('Saving to profiles:', profileData);
              const { error: profileErr } = await supabase
                .from('profiles')
                .upsert(profileData);

              if (profileErr) {
                console.error('profiles save error:', profileErr);
                // Don't treat RLS errors as fatal
                if (!profileErr.message?.includes('violates row-level security')) {
                  saveErrors.push('profile');
                }
              } else {
                console.log('Successfully saved to profiles');
              }
            } catch (e) {
              console.error('Exception saving to profiles:', e);
              // Don't treat profiles errors as fatal
            }

            // 3. Update auth user metadata (always succeeds)
            try {
              const metaData = {
                role: role,
                role_detail: role,
                avatar_url: avatar,
                site_id: siteId,
                team_id: teamIdNum,
                team_name: window.selectedTeamName || null,
                nickname: nicknameValue,
                full_name: user?.raw_user_meta_data?.full_name || user?.email?.split('@')[0] || 'Staff'
              };

              console.log('Updating auth metadata:', metaData);
              const { error: authErr } = await supabase.auth.updateUser({ data: metaData });

              if (authErr) {
                console.error('Auth metadata update error:', authErr);
              } else {
                console.log('Successfully updated auth metadata');
              }
            } catch(e) {
              console.error('Exception updating auth metadata:', e);
            }

            // Navigate to new Step 4: ask HH:MM or Sessions
            try {
              const step3 = document.getElementById('welcome-step3');
              const step4 = document.getElementById('step4');

              if (!step3 || !step4) {
                console.error('Step4 or Step3 missing for navigation');
                if (fm) fm.textContent = 'Saved. Redirecting…';
                setTimeout(() => { window.location.href = 'staff.html'; }, 1500);
              } else {
                step3.style.display = 'none';
                step4.style.display = 'block';
                window.scrollTo(0,0);
              }
            } catch (navError) {
              console.error('Navigation error to step4:', navError);
              if (fm) fm.textContent = 'Saved. Redirecting…';
              setTimeout(() => { window.location.href = 'staff.html'; }, 1500);
            }
          }); finish.dataset.bound='1'; }

          // Initial render
          updateAvatarPreview();
        }

        // Advanced Particle Explosion System
        window.createParticleExplosion = function createParticleExplosion(centerX, centerY, intensity = 1) {
          const conf = document.getElementById('confetti-container') || document.getElementById('confetti');
          if (!conf) return;

          const colors = [
            '#3b82f6', '#8b5cf6', '#06d6a0', '#f72585', '#ffb703',
            '#fb8500', '#219ebc', '#023047', '#e63946', '#2a9d8f'
          ];

          const particleTypes = ['explosion', 'sparkle', 'burst', 'glow', 'ring'];
          const numParticles = Math.floor(40 * intensity);

          for (let i = 0; i < numParticles; i++) {
            const type = particleTypes[Math.floor(Math.random() * particleTypes.length)];
            const particle = document.createElement('div');
            particle.className = `particle ${type}-particle`;

            // Random direction and distance
            const angle = (Math.PI * 2 * i) / numParticles + (Math.random() - 0.5) * 0.8;
            const distance = 80 + Math.random() * 200 * intensity;
            const dx = Math.cos(angle) * distance;
            const dy = Math.sin(angle) * distance;
            const rotation = Math.random() * 720 - 360;

            // Position at explosion center
            particle.style.left = centerX + 'px';
            particle.style.top = centerY + 'px';
            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
            particle.style.setProperty('--dx', dx + 'px');
            particle.style.setProperty('--dy', dy + 'px');
            particle.style.setProperty('--rotation', rotation + 'deg');
            particle.style.setProperty('--start-rotation', Math.random() * 360 + 'deg');
            particle.style.animationDelay = Math.random() * 0.3 + 's';

            // Special properties for different types
            if (type === 'ring') {
              particle.style.borderColor = colors[Math.floor(Math.random() * colors.length)];
            }

            conf.appendChild(particle);

            // Clean up
            setTimeout(() => {
              if (particle.parentNode) particle.remove();
            }, 3000);
          }
        }

        // Disney-style sparkle wave effect
        window.createDisneySparkleWave = function(centerX, centerY) {
          const conf = document.getElementById('confetti-container') || document.getElementById('confetti');
          if (!conf) return;
          
          const containerRect = conf.getBoundingClientRect();
          const relativeX = centerX - containerRect.left;
          const relativeY = centerY - containerRect.top;
          
          // Create expanding ring of sparkles
          for (let ring = 0; ring < 4; ring++) {
            const radius = 80 + (ring * 60);
            const sparkleCount = 12 + (ring * 6);
            
            for (let i = 0; i < sparkleCount; i++) {
              const angle = (Math.PI * 2 * i) / sparkleCount + (ring * 0.2);
              const x = relativeX + Math.cos(angle) * radius;
              const y = relativeY + Math.sin(angle) * radius;
              
              setTimeout(() => {
                createDisneySparkle(x, y, ring * 0.3);
              }, ring * 150 + (i * 30));
            }
          }
        }

        // Create individual Disney-style sparkle
        window.createDisneySparkle = function(x, y, delay = 0) {
          const conf = document.getElementById('confetti-container') || document.getElementById('confetti');
          if (!conf) return;

          const sparkle = document.createElement('div');
          sparkle.className = 'particle disney-sparkle';
          sparkle.style.left = x + 'px';
          sparkle.style.top = y + 'px';
          sparkle.style.animationDelay = delay + 's';
          
          // Random blue sparkle color
          const blueColors = ['#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#64B5F6', '#42A5F5'];
          const sparkleColor = blueColors[Math.floor(Math.random() * blueColors.length)];
          sparkle.style.background = sparkleColor;
          sparkle.style.boxShadow = `0 0 20px ${sparkleColor}, 0 0 40px ${sparkleColor}80, 0 0 60px ${sparkleColor}40`;
          
          conf.appendChild(sparkle);
          
          // Clean up
          setTimeout(() => {
            if (sparkle.parentNode) sparkle.remove();
          }, 3000);
        }

        // Disney-style sparkle explosion with blue theme
        window.createDisneySparkleExplosion = function(x, y, intensity = 1) {
          const conf = document.getElementById('confetti-container') || document.getElementById('confetti');
          if (!conf) return;

          const containerRect = conf.getBoundingClientRect();
          const relativeX = x - containerRect.left;
          const relativeY = y - containerRect.top;
          
          const particleCount = Math.floor(25 * intensity);
          const blueColors = ['#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#64B5F6', '#42A5F5', '#81C784', '#66BB6A'];
          
          for (let i = 0; i < particleCount; i++) {
            // Create sparkle particle
            const particle = document.createElement('div');
            particle.className = 'particle disney-sparkle-burst';
            particle.style.left = relativeX + 'px';
            particle.style.top = relativeY + 'px';
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 50 + Math.random() * 150 * intensity;
            const dx = Math.cos(angle) * distance;
            const dy = Math.sin(angle) * distance;
            const rotation = Math.random() * 720 + 360;
            
            particle.style.setProperty('--dx', dx + 'px');
            particle.style.setProperty('--dy', dy + 'px');
            particle.style.setProperty('--rotation', rotation + 'deg');
            particle.style.animationDelay = Math.random() * 0.2 + 's';
            
            const sparkleColor = blueColors[Math.floor(Math.random() * blueColors.length)];
            particle.style.background = sparkleColor;
            particle.style.boxShadow = `0 0 15px ${sparkleColor}, 0 0 30px ${sparkleColor}60, 0 0 45px ${sparkleColor}30`;
            
            conf.appendChild(particle);
            
            // Clean up
            setTimeout(() => {
              if (particle.parentNode) particle.remove();
            }, 2500);
          }
          
          // Add some floating magic dust
          for (let i = 0; i < 8; i++) {
            setTimeout(() => {
              const dust = document.createElement('div');
              dust.className = 'particle disney-magic-dust';
              dust.style.left = (relativeX - 20 + Math.random() * 40) + 'px';
              dust.style.top = (relativeY - 20 + Math.random() * 40) + 'px';
              
              const dustColor = blueColors[Math.floor(Math.random() * blueColors.length)];
              dust.style.background = `radial-gradient(circle, ${dustColor}ff 0%, ${dustColor}80 40%, transparent 70%)`;
              dust.style.filter = 'blur(1px)';
              
              conf.appendChild(dust);
              
              setTimeout(() => {
                if (dust.parentNode) dust.remove();
              }, 4000);
            }, i * 100);
          }
        }

        window.createTextBurstEffect = function createTextBurstEffect() {
          const banner = document.querySelector('.complete-banner');
          if (!banner) return;

          const rect = banner.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          // Disney-style sparkle wave effect
          createDisneySparkleWave(centerX, centerY);
          
          // Multiple cascading sparkle explosions
          const explosionPoints = [
            { x: centerX - 120, y: centerY - 20, intensity: 1.0, delay: 0 },
            { x: centerX + 120, y: centerY - 20, intensity: 1.0, delay: 200 },
            { x: centerX, y: centerY - 80, intensity: 1.5, delay: 100 },
            { x: centerX - 60, y: centerY + 40, intensity: 0.8, delay: 300 },
            { x: centerX + 60, y: centerY + 40, intensity: 0.8, delay: 350 },
            { x: centerX - 150, y: centerY - 60, intensity: 0.6, delay: 450 },
            { x: centerX + 150, y: centerY - 60, intensity: 0.6, delay: 500 }
          ];

          explosionPoints.forEach((point) => {
            setTimeout(() => {
              createDisneySparkleExplosion(point.x, point.y, point.intensity);
            }, point.delay);
          });
        }

        window.burstConfetti = function burstConfetti() {
          // Create Disney-style sparkle explosions at multiple points
          const conf = document.getElementById('confetti-container') || document.getElementById('confetti');
          if (!conf) return;

          const containerRect = conf.getBoundingClientRect();
          const explosions = [
            { x: containerRect.width * 0.15, y: containerRect.height * 0.25, intensity: 1.2 },
            { x: containerRect.width * 0.85, y: containerRect.height * 0.25, intensity: 1.2 },
            { x: containerRect.width * 0.5, y: containerRect.height * 0.45, intensity: 1.5 },
            { x: containerRect.width * 0.3, y: containerRect.height * 0.65, intensity: 1.0 },
            { x: containerRect.width * 0.7, y: containerRect.height * 0.65, intensity: 1.0 }
          ];

          explosions.forEach((explosion, index) => {
            setTimeout(() => {
              // Convert to absolute coordinates for Disney sparkle function
              const absX = containerRect.left + explosion.x;
              const absY = containerRect.top + explosion.y;
              createDisneySparkleExplosion(absX, absY, explosion.intensity);
              
              // Add some traditional confetti mixed in
              createParticleExplosion(explosion.x, explosion.y, explosion.intensity * 0.6);
            }, index * 180);
          });
        }

        window.showBalloons = function showBalloons(){
          const container = document.getElementById('step5');
          if (!container) return;

          // Enhanced balloon emojis with more sparkly/magical theme
          const balloonEmojis = ['🎈', '✨', '�', '💫', '🎊', '🎉', '💎', '🔮'];
          const blueSparkleColors = ['#4FC3F7', '#29B6F6', '#03A9F4', '#81C784', '#66BB6A'];
          
          for (let i = 0; i < 12; i++) {
            const balloon = document.createElement('div');
            balloon.style.position = 'absolute';
            balloon.style.fontSize = (35 + Math.random() * 20) + 'px';
            balloon.style.left = (5 + Math.random() * 90) + '%';
            balloon.style.bottom = '-80px';
            balloon.style.zIndex = '15';
            
            const emoji = balloonEmojis[Math.floor(Math.random() * balloonEmojis.length)];
            balloon.textContent = emoji;
            
            // Add sparkly glow to certain emojis
            if (['✨', '🌟', '💫', '💎', '🔮'].includes(emoji)) {
              const sparkleColor = blueSparkleColors[Math.floor(Math.random() * blueSparkleColors.length)];
              balloon.style.textShadow = `0 0 20px ${sparkleColor}, 0 0 40px ${sparkleColor}80, 0 0 60px ${sparkleColor}40`;
              balloon.style.filter = 'brightness(1.3) saturate(1.2)';
            }
            
            balloon.style.animation = `floatUp ${2.5 + Math.random() * 2}s ease-out forwards`;
            balloon.style.animationDelay = Math.random() * 0.8 + 's';
            container.appendChild(balloon);
            
            setTimeout(() => balloon.remove(), 6000);
          }
          
          // Add some floating sparkle trails
          for (let i = 0; i < 8; i++) {
            setTimeout(() => {
              const sparkleTrail = document.createElement('div');
              sparkleTrail.style.position = 'absolute';
              sparkleTrail.style.left = (10 + Math.random() * 80) + '%';
              sparkleTrail.style.bottom = '-20px';
              sparkleTrail.style.width = '4px';
              sparkleTrail.style.height = '4px';
              sparkleTrail.style.zIndex = '8';
              sparkleTrail.className = 'disney-sparkle';
              
              const sparkleColor = blueSparkleColors[Math.floor(Math.random() * blueSparkleColors.length)];
              sparkleTrail.style.background = sparkleColor;
              sparkleTrail.style.boxShadow = `0 0 15px ${sparkleColor}, 0 0 30px ${sparkleColor}60`;
              sparkleTrail.style.animation = `floatUp ${4 + Math.random() * 2}s ease-out forwards, disneySparkle ${2 + Math.random()}s ease-out infinite`;
              
              container.appendChild(sparkleTrail);
              setTimeout(() => sparkleTrail.remove(), 7000);
            }, i * 150);
          }
        }

        async function saveNickname(){
          const input = document.getElementById('nickname');
          const msg = document.getElementById('save-msg');
          msg.textContent = '';
          const val = String(input.value || '').trim();
          if (!val) { msg.textContent = 'Please enter a name to continue.'; return; }

          // First, try to save to master_users table - update nickname and role if selected
          try {
            // Update nickname and role_detail if set
            const updateData = {
              nickname: val,
              updated_at: new Date().toISOString()
            };

            // Include role if it has been selected
            if (window.selectedRole) {
              updateData.role_detail = window.selectedRole;
              console.log('Saving role_detail to master_users:', window.selectedRole);
            }

            const { error: masterError } = await supabase
              .from('master_users')
              .update(updateData)
              .eq('auth_user_id', user.id)
              .eq('site_id', siteId);

            if (!masterError) {
              msg.textContent = 'Saved!';
              // Move directly to step 3 (avatar)
              document.getElementById('welcome-step1').style.display = 'none';
              document.getElementById('welcome-step3').style.display = '';
              await initAvatarBuilder(fullName);
              return;
            } else {
              console.error('Master users save failed:', masterError);
              msg.textContent = `Error saving nickname: ${masterError.message || 'Please try again.'}`;
              return;
            }
          } catch(e) {
            console.error('Master users save failed:', e);
            msg.textContent = 'Error saving nickname. Please try again or contact support.';
            return;
          }
        }

        const saveBtn = document.getElementById('save-btn');
        if (saveBtn) {
          saveBtn.addEventListener('click', (e)=>{ e.preventDefault(); saveNickname(); });
        } else {
          console.warn('[staff-welcome] save-btn not found');
        }

        // ---- Step 2 helpers ----

        const ROLE_ICON = (name) => ({
          // Using Icons8 Cute Color style (48px). Slugs chosen as reasonable defaults.
          'Doctor': 'https://img.icons8.com/cute-color/48/stethoscope.png',
          'Nurse': 'https://img.icons8.com/cute-color/48/nurse.png',
          'Pharmacist': 'https://img.icons8.com/cute-color/48/pill.png',
          'Reception': 'https://img.icons8.com/cute-color/48/customer-support.png',
          'Manager': 'https://img.icons8.com/cute-color/48/briefcase.png'
        })[name] || 'https://img.icons8.com/cute-color/48/user-male.png';

        // Local fallback icons (in case external hosting is blocked)
        const ROLE_ICON_FALLBACK = (name) => ({
          'Doctor': 'Icons/icons8-stethoscope-100.png',
          'Nurse': 'Icons/icons8-nurse-100.png',
          'Pharmacist': 'Icons/icons8-pharmacist-100.png',
          'Reception': 'Icons/icons8-group-100.png',
          'Manager': 'Icons/icons8-doctors-bag-100.png'
        })[name] || 'Icons/icons8-profile-100.png';

        async function loadDetailsData(siteId, fullName){
          // Load existing welcome data (if any)
          let existing = null;

          // Check if we have pre-configured data from admin setup
          if (window.preConfiguredData && window.preConfiguredData.welcome) {
            existing = window.preConfiguredData.welcome;
            console.log('Using pre-configured welcome data:', existing);
          } else {
            // Load from master_users first (primary source of truth)
            try {
              const { data: masterData, error: masterError } = await supabase
                .from('master_users')
                .select('full_name, nickname, role_detail, team_id, team_name, avatar_url')
                .eq('auth_user_id', user.id)
                .eq('site_id', siteId)
                .maybeSingle();
              
              if (!masterError && masterData) {
                existing = masterData;
                console.log('Using master_users data:', existing);
              } else {
                // Try again without site_id filter if no data found
                console.log('No master_users data found with site filter, trying without site filter');
                const { data: masterDataNoSite, error: masterErrorNoSite } = await supabase
                  .from('master_users')
                  .select('full_name, nickname, role_detail, team_id, team_name, avatar_url')
                  .eq('auth_user_id', user.id)
                  .limit(1)
                  .maybeSingle();
                if (!masterErrorNoSite && masterDataNoSite) {
                  existing = masterDataNoSite;
                  console.log('Using master_users data (no site filter):', existing);
                }
              }
            } catch (e) {
              console.warn('Error loading user details:', e);
            }
          }

          // Pre-fill nickname if present
          if (existing) {
            const nn = document.getElementById('nickname');
            if (nn && !nn.value) nn.value = existing.nickname || existing.full_name || nn.value;
            if (existing.avatar_url) {
              window.existingAvatarUrl = existing.avatar_url;
              window.currentSavedAvatarUrl = existing.avatar_url;
              // Pre-populate avatar preview if exists
              const avatarPreview = document.getElementById('avatarPreview');
              if (avatarPreview) avatarPreview.src = existing.avatar_url;
            }

            // Pre-select role and team if configured
            if (existing.role_detail) {
              window.selectedRole = existing.role_detail;
            }
            if (existing.team_id) {
              window.selectedTeamId = existing.team_id;
              window.selectedTeamName = existing.team_name;
            }
          }

          // Use pre-configured values from invitation if not already set
          if (!window.selectedRole && window.preConfiguredRole) {
            window.selectedRole = window.preConfiguredRole;
          }
          if (!window.selectedTeamId && window.preConfiguredTeamId) {
            window.selectedTeamId = window.preConfiguredTeamId;
          }

          // Build Roles list (value/label pairs) and prefer canonical admin order
          const canonicalRoles = [
            { value: 'GP', label: 'GP (Doctor)' },
            { value: 'Nurse', label: 'Nurse' },
            { value: 'Practice Manager', label: 'Practice Manager' },
            { value: 'Admin Assistant', label: 'Admin Assistant' },
            { value: 'Receptionist', label: 'Receptionist' },
            { value: 'Healthcare Assistant', label: 'Healthcare Assistant' },
            { value: 'Pharmacist', label: 'Pharmacist' },
            { value: 'Other', label: 'Other' }
          ];

          let roles = [];
          try {
            const { data, error } = await supabase.from('kiosk_roles').select('role');
            if (!error && Array.isArray(data) && data.length) {
              // Map DB roles to value/label pairs, preserving order from canonical when possible
              const dbRoles = data.map(r => String(r.role));
              const added = new Set();
              // First add canonical roles that exist in DB (or always keep canonical order)
              canonicalRoles.forEach(cr => {
                if (dbRoles.includes(cr.value) || dbRoles.includes(cr.label) || true) {
                  roles.push({ value: cr.value, label: cr.label });
                  added.add(cr.value);
                }
              });
              // Then append any DB-only roles not already present
              dbRoles.forEach(r => {
                const v = String(r);
                if (!added.has(v)) {
                  roles.push({ value: v, label: v });
                  added.add(v);
                }
              });
            }
          } catch(_) {}

          if (!roles.length) roles = canonicalRoles.slice();

          // Ensure existing role appears in list (handle raw saved values)
          if (existing && existing.role_detail) {
            const exists = roles.some(rr => rr.value === existing.role_detail || rr.label === existing.role_detail);
            if (!exists) roles = [{ value: existing.role_detail, label: existing.role_detail }, ...roles];
          }

          const rg = document.getElementById('role-grid');
          // expose helper to set fallback src when onerror fires
          window.__roleIconFallback = function(el, role){
            try{ el.onerror = null; el.src = ROLE_ICON_FALLBACK(role); }catch(e){}
          };
          rg.innerHTML = roles.map((r,i)=>{
            // Determine a pre-selected value from existing data or preconfigured invite
            const pre = window.selectedRole || window.preConfiguredRole || (existing && existing.role_detail) || null;
            const checked = pre ? (pre === r.value || pre === r.label) : (i===0);
            const val = esc(String(r.value || r.label));
            const lbl = esc(String(r.label || r.value));
            return `<label class=\"option-pill white-pill\">\n              <input type=\"radio\" name=\"role\" value=\"${val}\" ${checked?'checked':''} />\n              <img src=\"${ROLE_ICON(lbl)}\" alt=\"${lbl}\" style=\"width:32px;height:32px;object-fit:contain;\" onerror=\"window.__roleIconFallback(this,'${lbl}')\"/\>\n              <span>${lbl}</span>\n            </label>`;
          }).join('');

          // Load teams by site (button grid like roles)
          const tg = document.getElementById('team-grid');
          tg.innerHTML = '<div style="opacity:.7; padding:8px 0;">Loading teams…</div>';
          try{
            let teams = [];
            // Try to load teams from database
            if (siteId){
              try {
                const { data, error } = await supabase.from('teams').select('id,name').eq('site_id', siteId).order('name');
                if (error) {
                  console.warn('teams load error (using fallback)', error);
                  teams = [];
                } else {
                  teams = (data||[]).map(team => ({ id: team.id, name: team.name }));
                  console.log('Loaded teams from database:', teams);
                }
              } catch (e) {
                console.warn('teams query exception (using fallback)', e);
                teams = [];
              }
            }

            // Always provide fallback teams if none loaded (match admin-dashboard defaults)
            if (!teams.length) {
              console.log('Using fallback teams');
              teams = [
                { id: 1, name: 'Clinical Team' },
                { id: 2, name: 'Admin Team' },
                { id: 3, name: 'Reception' },
                { id: 4, name: 'Management' }
              ];
            }

            if (siteId) {
              const html = teams.map((t) => {
                const isExisting = existing && ((existing.team_id && String(existing.team_id) === String(t.id)) || (existing.team_name && existing.team_name === t.name));
                return `<label class=\"option-pill white-pill\">\n                  <input type=\"radio\" name=\"team\" value=\"${String(t.id)}\" data-name=\"${t.name}\" ${isExisting ? 'checked' : ''} />\n                  <img src=\"Icons/icons8-people-100.png\" alt=\"${t.name}\" style=\"width:32px;height:32px;object-fit:contain;\"/>\n                  <span>${t.name}</span>\n                </label>`;
              }).join('');
              tg.innerHTML = html || '<div style="opacity:.7; padding:8px 0;">No teams found for this site.</div>';

              // Bind and initialize selection globals
              const onTeamChange = () => {
                const checked = document.querySelector('input[name="team"]:checked');
                if (checked) {
                  window.selectedTeamId = checked.value && /^\\d+$/.test(String(checked.value)) ? parseInt(checked.value, 10) : null;
                  window.selectedTeamName = checked.dataset.name || null;
                } else {
                  window.selectedTeamId = null;
                  window.selectedTeamName = null;
                }
              };
              tg.querySelectorAll('input[name="team"]').forEach(el => el.addEventListener('change', onTeamChange));
              onTeamChange();
            } else {
              tg.innerHTML = '<div style="opacity:.7; padding:8px 0;">No site set</div>';
            }
          }catch(_){ tg.innerHTML = '<div style="opacity:.7; padding:8px 0;">Could not load teams</div>'; }

          // Persist selections helper
          async function persistRoleTeam(role, teamIdNum, teamName, avatarUrl){
            const msgEl = document.getElementById('finish-msg');
            try {
              // 1) Update master_users table (primary source of truth)
              try {
                const nicknameVal = String(document.getElementById('nickname')?.value || '').trim() || null;
                if (!siteId) {
                  if (msgEl) msgEl.textContent = 'No site detected — saving to master_users without site.';
                }
                const payload = {
                  nickname: nicknameVal,
                  role_detail: role || null,
                  team_id: teamIdNum ?? null,
                  team_name: teamName || null,
                  avatar_url: avatarUrl ?? null,
                  updated_at: new Date().toISOString()
                };
                const { error: masterErr } = await supabase
                  .from('master_users')
                  .update(payload)
                  .eq('auth_user_id', user.id)
                  .eq('site_id', siteId || currentSiteId);
                if (masterErr) {
                  console.warn('Could not update master_users:', masterErr);
                  if (msgEl) msgEl.textContent = `Updating master_users...`;
                } else {
                  console.log('Successfully updated master_users');
                }
              } catch (e) {
                console.warn('Master users update failed:', e);
                if (msgEl) msgEl.textContent = 'Updating user data...';
              }

              // 2) profiles table is no longer used - master_users is the primary source
              // Commenting out profiles update to prevent confusion
              /*
              try {
                const profileData = {
                  user_id: user.id,
                  full_name: fullName,
                  nickname: String(document.getElementById('nickname')?.value || '').trim() || null,
                  role: (role || 'staff').toLowerCase(),
                  onboarding_complete: true
                };
                if (siteId) profileData.site_id = siteId;
                const { error: pErr } = await supabase.from('profiles').upsert(profileData);
                if (pErr) { console.warn('[welcome] profiles upsert failed', pErr); }
              } catch (e2) {
                console.warn('[welcome] profiles upsert exception', e2);
              }
              */
              if (msgEl) msgEl.textContent = 'Saved!';
            } catch (e) {
              console.warn('[welcome] persist selections failed', e);
              if (msgEl) msgEl.textContent = 'Could not save selections (continuing)…';
            }
          }

          // Continue to Step 3 (Avatar Builder)
          const toAvatar = document.getElementById('to-avatar-btn');
          if (toAvatar && !toAvatar.dataset.bound){
            toAvatar.addEventListener('click', async () => {
              const role = (document.querySelector('input[name="role"]:checked')?.value || '').trim();
              const teamRadio = document.querySelector('input[name="team"]:checked');
              const teamVal = teamRadio?.value || '';
              const teamName = teamRadio?.dataset.name || null;

              window.selectedRole = role || null;
              window.selectedTeamId = teamVal && /^\d+$/.test(String(teamVal)) ? parseInt(teamVal, 10) : null;
              window.selectedTeamName = teamName || null;

              // Persist immediately so selections are saved even if user leaves before finishing
              const btn = toAvatar;
              const msgEl = document.getElementById('finish-msg');
              if (msgEl) msgEl.textContent = '';
              btn.disabled = true;
              try {
                await persistRoleTeam(window.selectedRole, window.selectedTeamId, window.selectedTeamName);
              } finally {
                btn.disabled = false;
              }

              document.getElementById('welcome-step2').style.display = 'none';
              document.getElementById('welcome-step3').style.display = '';
              await initAvatarBuilder(fullName);

              // Wire up group toggles (allow collapse/expand)
              try {
                document.querySelectorAll('.group-toggle').forEach(btn => {
                  const target = document.querySelector(btn.dataset.target);
                  if (!target) return;
                  btn.addEventListener('click', () => {
                    const collapsed = target.classList.toggle('collapsed');
                    btn.textContent = collapsed ? 'Show' : 'Hide';
                  });
                });
              } catch (e) { /* non-critical */ }

              // Function to prefill avatar from existing data
              async function prefillAvatarFromExisting() {
                if (window.avatarPrefilled) return; // Prevent duplicate calls
                window.avatarPrefilled = true;

                try {
                  if (window.existingAvatarUrl) {
                    const url = String(window.existingAvatarUrl);
                    window.currentAvatarUrl = url;
                    window.currentSavedAvatarUrl = url;
                    const img = document.getElementById('avatarPreview');
                    if (img) img.src = url;

                    // Parse parameters from DiceBear URL and apply to controls
                    const u = new URL(url);
                    const p = u.searchParams;
                    const map = new Map([
                      ['backgroundType','opt-backgroundType'],
                      ['backgroundColor','opt-backgroundColor'],
                      ['backgroundRotation','opt-backgroundRotation'],
                      ['radius','opt-radius'],
                      ['rotate','opt-rotate'],
                      ['scale','opt-scale'],
                      ['flip','opt-flip'],
                      ['clip','opt-clip'],
                      ['translateX','opt-translateX'],
                      ['translateY','opt-translateY'],
                      ['eyes','opt-eyes'],
                      ['mouth','opt-mouth'],
                      ['eyebrows','opt-eyebrows'],
                      ['glasses','opt-glasses'],
                      ['glassesProbability','opt-glassesProbability'],
                      ['earrings','opt-earrings'],
                      ['earringsProbability','opt-earringsProbability'],
                      ['featuresProbability','opt-featuresProbability'],
                      ['hair','opt-hair'],
                      ['hairColor','opt-hairColor'],
                      ['hairProbability','opt-hairProbability'],
                      ['skinColor','opt-skinColor'],
                    ]);
                    for (const [k,id] of map.entries()){
                      const v = p.get(k);
                      if (v != null && v !== ''){
                        const el = document.getElementById(id);
                        if (el) el.value = v;
                      }
                    }
                    // Handle features (multi)
                    const feats = p.getAll('features');
                    if (feats && feats.length){
                      const fEl = document.getElementById('opt-features');
                      if (fEl){
                        for (const o of Array.from(fEl.options)) o.selected = feats.includes(o.value);
                      }
                    }
                    // Seed
                    const seed = p.get('seed');
                    if (seed) { window.aiSeed = seed; }

                    updateAvatarPreview();
                    // Hide Save button since this avatar is already saved
                    const saveBtn = document.getElementById('avatar-save');
                    if (saveBtn) saveBtn.style.display = 'none';
                  }
                } catch (e) { console.info('avatar prefill failed', e); }
              }

              // Prefill avatar when navigating to avatar step
              await prefillAvatarFromExisting();
            });
            toAvatar.dataset.bound = '1';
          }
        }
      } catch(e){
        if (String(e.message).includes('NO_SESSION')) { window.location.replace('home.html'); return; }
        if (String(e.message).includes('NOT_STAFF')) { window.location.replace('home.html'); return; }
        console.error('[staff-welcome] error', e);
      }
    })();

    // Ensure avatar prefill runs when avatar step is visible on page load
    (function ensureAvatarPrefillOnLoad(){
      const avatarStep = document.getElementById('welcome-step3');
      if (avatarStep && avatarStep.style.display !== 'none') {
        // Avatar step is already visible, prefill immediately
        setTimeout(() => {
          if (typeof prefillAvatarFromExisting === 'function') {
            prefillAvatarFromExisting();
          }
        }, 100); // Small delay to ensure DOM is ready
      }
    })();

    // Render per-day working pattern form and handle save
    function pad2(n){ return String(n).padStart(2,'0'); }
    async function renderWorkingPatternForm(isGP) {
      const container = document.getElementById('working-pattern-form');
      if (!container) return;
      container.querySelectorAll('.day-row, .day-header')?.forEach(n=>n.remove());
      const days = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
      const note = document.getElementById('working-pattern-note');
      if (note) note.textContent = isGP ? 'Enter sessions per day (1 or 2).' : 'Enter hours per day (HH:MM). Defaults Mon-Fri 07:30.';

      // Try loading existing values from master_users
      let existing = null;
      try {
        if (window.currentUser && globalSupabase) {
          const { data } = await globalSupabase.from('master_users').select('*').eq('auth_user_id', window.currentUser.id).eq('site_id', window.currentSiteId).maybeSingle();
          if (data) existing = data;
        }
      } catch (e) { console.warn('Could not load master_users pattern', e); }

  // Header
  const header = document.createElement('div');
  header.className = 'day-header';
  header.style.display = 'grid';
  header.style.gridTemplateColumns = '1fr auto';
  header.style.gap = '12px';
  header.style.padding = '12px 16px';
  header.style.background = 'linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%)';
  header.style.border = '1px solid rgba(15,23,42,0.12)';
  header.style.borderRadius = '12px';
  header.style.color = '#0f172a';
  header.style.fontWeight = '800';
  header.style.fontSize = '14px';
  header.style.textTransform = 'uppercase';
  header.style.letterSpacing = '0.5px';
  header.style.marginBottom = '16px';
  const hDay = document.createElement('div'); hDay.textContent = 'Day';
  const hVal = document.createElement('div'); hVal.textContent = isGP ? 'Sessions' : 'Hours'; hVal.style.justifySelf = 'end';
  header.appendChild(hDay); header.appendChild(hVal);
  container.appendChild(header);      days.forEach((day, idx) => {
        const row = document.createElement('div'); row.className = 'day-row';
    row.style.display = 'grid';
    row.style.gridTemplateColumns = '1fr auto';
    row.style.alignItems = 'center';
    row.style.padding = '16px 20px';
    row.style.border = '1px solid rgba(15,23,42,0.12)';
    row.style.borderRadius = '16px';
    row.style.background = 'linear-gradient(135deg, #ffffff 0%, #f8fafc 100%)';
    row.style.boxShadow = '0 8px 25px rgba(15,23,42,0.08)';
    row.style.marginBottom = '12px';
    row.style.transition = 'transform 0.2s ease';
    const label = document.createElement('div'); label.textContent = day.charAt(0).toUpperCase() + day.slice(1); label.style.color = '#0f172a'; label.style.fontWeight = '800'; label.style.fontSize = '15px';
    const control = document.createElement('div'); control.style.display = 'flex'; control.style.alignItems = 'center'; control.style.gap = '8px';        if (isGP) {
          const select = document.createElement('select'); select.id = `${day}-sessions`;
          select.style.padding = '12px 14px';
          select.style.borderRadius = '12px';
          select.style.border = '1px solid rgba(15,23,42,0.2)';
          select.style.background = 'white';
          select.style.fontSize = '15px';
          select.style.fontWeight = '700';
          select.style.color = '#0f172a';
          select.style.boxShadow = '0 2px 8px rgba(15,23,42,0.1)';
          ['0','1','2'].forEach(v => { const o = document.createElement('option'); o.value = v; o.textContent = v; select.appendChild(o); });
          const existingVal = existing ? (existing[`${day}_sessions`] ?? '0') : (idx < 5 ? '2' : '0');
          select.value = String(existingVal);
          control.appendChild(select);
          const noteS = document.createElement('span'); noteS.className='tiny-note'; noteS.textContent='sessions'; noteS.style.color='#475569'; noteS.style.fontWeight='600'; control.appendChild(noteS);
        } else {
          const h = document.createElement('input'); h.type='number'; h.min='0'; h.max='23'; h.style.width='72px'; h.id = `${day}-hours`;
          const m = document.createElement('input'); m.type='number'; m.min='0'; m.max='59'; m.style.width='72px'; m.id = `${day}-minutes`;
          [h,m].forEach(inp => { inp.style.padding='12px 14px'; inp.style.borderRadius='12px'; inp.style.border='1px solid rgba(15,23,42,0.2)'; inp.style.background='white'; inp.style.fontSize='15px'; inp.style.fontWeight='700'; inp.style.color='#0f172a'; inp.style.boxShadow='0 2px 8px rgba(15,23,42,0.1)'; });
          const existingHours = existing ? (existing[`${day}_hours`] ?? null) : null;
          if (existingHours !== null && existingHours !== undefined && existingHours !== 0) {
            const hours = Math.floor(Number(existingHours));
            const minutes = Math.round((Number(existingHours) - hours) * 60);
            h.value = hours; m.value = minutes;
          } else {
            if (idx < 5) { h.value = '7'; m.value = '30'; } else { h.value='0'; m.value='0'; }
          }
          control.appendChild(h); const labelH = document.createElement('span'); labelH.textContent='h'; labelH.style.margin='0 6px'; labelH.style.color='#475569'; labelH.style.fontWeight='600'; control.appendChild(labelH);
          control.appendChild(m); const labelM = document.createElement('span'); labelM.textContent='m'; labelM.style.margin='0 6px'; labelM.style.color='#475569'; labelM.style.fontWeight='600'; control.appendChild(labelM);
        }

        row.appendChild(label); row.appendChild(control); container.appendChild(row);
      });
    }

    // Wire working-pattern navigation and finish
    (function bindWorkingPatternNav(){
      const back = document.getElementById('working-pattern-back');
      const finish = document.getElementById('working-pattern-finish');
      if (back && !back.dataset.bound) { back.addEventListener('click', () => {
        document.getElementById('working-pattern-step').style.display = 'none';
        const s4 = document.getElementById('step4'); if (s4) s4.style.display = 'block'; window.scrollTo(0,0);
      }); back.dataset.bound = '1'; }

      if (finish && !finish.dataset.bound) { finish.addEventListener('click', async () => {
        const msg = document.getElementById('working-pattern-msg'); if (msg) msg.textContent = 'Saving...';
        try {
          const days = ['sunday','monday','tuesday','wednesday','thursday','friday','saturday'];
          const isGP = (document.querySelector('input[name="work-type"]:checked')?.value === 'sessions');
          const payload = { auth_user_id: window.currentUser.id, site_id: window.currentSiteId || window.currentUser?.user_metadata?.site_id || window.currentUser?.raw_user_meta_data?.site_id || 2, updated_at: new Date().toISOString() };
          let totalHours = 0, totalSessions = 0;
          for (const day of days) {
            if (isGP) {
              const v = document.getElementById(`${day}-sessions`); const s = parseInt(v?.value || '0',10) || 0; payload[`${day}_sessions`] = s; payload[`${day}_hours`] = 0; totalSessions += s;
            } else {
              const h = parseInt(document.getElementById(`${day}-hours`)?.value || '0',10) || 0; const m = parseInt(document.getElementById(`${day}-minutes`)?.value || '0',10) || 0; const dec = h + (m/60); payload[`${day}_hours`] = dec; payload[`${day}_sessions`] = 0; totalHours += dec;
            }
          }
          payload.total_hours = totalHours; payload.total_sessions = totalSessions; payload.weekly_hours = totalHours; payload.weekly_sessions = totalSessions; payload.is_gp = isGP;

          // Save with update-then-insert fallback
          try {
            const upd = await globalSupabase.from('master_users').update(payload).eq('auth_user_id', payload.auth_user_id).eq('site_id', payload.site_id).select('id');
            const updatedRows = Array.isArray(upd.data) ? upd.data.length : (upd.data ? 1 : 0);
                if (updatedRows === 0) {
                  // Ensure access_type is set on new rows to avoid DB defaulting to 'staff'
                  try {
                    const originalRole = user?.user_metadata?.role || user?.raw_user_meta_data?.role || user?.app_metadata?.role || 'Staff';
                    let accessType = 'staff';
                    if (String(originalRole).toLowerCase() === 'admin' || user?.user_metadata?.admin_access === true) accessType = 'admin';
                    else if (String(originalRole).toLowerCase() === 'owner') accessType = 'owner';
                    payload.access_type = accessType;
                    console.log('[Step4] Setting access_type for new master_users row:', accessType);
                  } catch (_) {}

                  const ins = await globalSupabase.from('master_users').insert([payload]).select('id');
              if (ins.error) { console.error('Insert master_users failed', ins.error); if (msg) msg.textContent = '⚠️ Save failed; continuing.'; }
            }
            window.currentMasterIsGp = payload.is_gp;
            if (msg) msg.textContent = '✅ Saved.';
          } catch (e) { console.error('Error saving working pattern', e); if (msg) msg.textContent = '⚠️ Save failed; continuing.'; }

          try { await globalSupabase.auth.updateUser({ data: { welcome_completed_at: new Date().toISOString(), onboarding_required: false } }); } catch(_){}

          // Show completion
          document.getElementById('working-pattern-step').style.display = 'none'; const s5 = document.getElementById('step5'); if (s5) s5.style.display = 'block';
          setTimeout(() => { if (typeof burstConfetti === 'function') burstConfetti(); }, 200);
          setTimeout(() => { window.location.href = 'staff.html'; }, 1700);

        } catch (e) { console.error('working-pattern finish failed', e); const s5 = document.getElementById('step5'); if (s5) s5.style.display = 'block'; setTimeout(() => { window.location.href = 'staff.html'; }, 1500); }
      }); finish.dataset.bound = '1'; }
    })();
    
    // Icon service functions
    function i8(name, opts = {}) {
      var base  = 'https://img.icons8.com';
      var style = opts.style || 'cute-color';
      var size  = opts.size  || 48;
      // Icons8 OMG-IMG pattern is style/size/name.png
      var path  = [style, String(size), encodeURIComponent(name) + '.png'].join('/');
      return base + '/' + path;
    }
    
    function setIcon(el){
      var name  = el.getAttribute('data-i8');
      var size  = el.getAttribute('data-i8-size');
      var style = el.getAttribute('data-i8-style') || 'fluency';
      var fallback = (el.getAttribute('data-i8-fallback') || '').toLowerCase();
      
      if (fallback === 'auto') {
        var stylesToTry = [style, 'fluency', 'color'];
        var idx = 0;
        function tryNext(){
          if (idx >= stylesToTry.length) { el.onerror = null; return; }
          var url = i8(name, {style: stylesToTry[idx++], size: size ? parseInt(size,10) : undefined});
          if (el.src !== url) el.src = url; else tryNext();
        }
        el.onerror = tryNext;
        tryNext();
      } else {
        el.src = i8(name, {style: style, size: size ? parseInt(size,10) : undefined});
      }
    }
    
    function wireIcons(){
      document.querySelectorAll('img[data-i8]').forEach(setIcon);
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', wireIcons);
    } else {
      wireIcons();
    }
    
    // Working hours step and related handlers removed.

    // Step 4 handlers: choice between hours or sessions
    (function bindStep4Handlers(){
      const back = document.getElementById('step4-back');
      const next = document.getElementById('step4-next');
      if (back && !back.dataset.bound) {
        back.addEventListener('click', () => {
          document.getElementById('step4').style.display = 'none';
          const step3 = document.getElementById('welcome-step3');
          if (step3) step3.style.display = '';
          window.scrollTo(0,0);
        });
        back.dataset.bound = '1';
      }

      if (next && !next.dataset.bound) {
        next.addEventListener('click', async () => {
          const msg = document.getElementById('step4-msg');
          try {
            const sel = document.querySelector('input[name="work-type"]:checked');
            const choice = sel ? sel.value : 'hours';
            const isGP = (choice === 'sessions');
            if (msg) msg.textContent = 'Saving your preference…';

            if (window.currentUser && globalSupabase) {
              const payload = {
                auth_user_id: window.currentUser.id,
                site_id: window.currentSiteId || window.currentUser?.user_metadata?.site_id || window.currentUser?.raw_user_meta_data?.site_id || 2,
                is_gp: isGP,
                updated_at: new Date().toISOString()
              };
              // Try update first (safe when row exists), then insert if no row updated
              try {
                const upd = await globalSupabase
                  .from('master_users')
                  .update({ is_gp: payload.is_gp, updated_at: payload.updated_at })
                  .eq('auth_user_id', payload.auth_user_id)
                  .eq('site_id', payload.site_id)
                  .select('id');
                if (upd.error) {
                  console.warn('master_users update error, will try insert', upd.error);
                }
                const updatedRows = Array.isArray(upd.data) ? upd.data.length : (upd.data ? 1 : 0);
                if (updatedRows === 0) {
                  // No existing row, insert one
                  const ins = await globalSupabase
                    .from('master_users')
                    .insert([payload])
                    .select('id');
                  if (ins.error) {
                    console.error('Error inserting master_users row for is_gp', ins.error);
                    if (msg) msg.textContent = '⚠️ Could not save preference; continuing.';
                  } else {
                    if (msg) msg.textContent = '✅ Preference saved.';
                    window.currentMasterIsGp = payload.is_gp;
                  }
                } else {
                  if (msg) msg.textContent = '✅ Preference saved.';
                  window.currentMasterIsGp = payload.is_gp;
                }
              } catch (e) {
                console.error('Exception saving is_gp to master_users', e);
                if (msg) msg.textContent = '⚠️ Could not save preference; continuing.';
              }
            } else {
              console.warn('Missing user or DB when saving is_gp');
              if (msg) msg.textContent = '⚠️ Missing connection; continuing.';
            }

            try { await globalSupabase.auth.updateUser({ data: { welcome_completed_at: new Date().toISOString(), onboarding_required: false } }); } catch(_){}

            // Proceed to working-pattern step to collect per-day values
            document.getElementById('step4').style.display = 'none';
            const wp = document.getElementById('working-pattern-step');
            if (!wp) {
              // Fallback to completion
              const step5 = document.getElementById('step5'); if (step5) step5.style.display = 'block';
              setTimeout(() => { window.location.href = 'staff.html'; }, 1500);
            } else {
              wp.style.display = 'block';
              // Render the working pattern form according to isGP
              try { renderWorkingPatternForm(isGP); } catch (e) { console.error('renderWorkingPatternForm failed', e); }
            }

          } catch (e) {
            console.error('Step4 next handler failed', e);
            const step5 = document.getElementById('step5'); if (step5) step5.style.display = 'block';
            setTimeout(() => { window.location.href = 'staff.html'; }, 1500);
          }
        });
        next.dataset.bound = '1';
      }
    })();
  </script>

    <!-- Debug Console - Persistent across all pages -->
    <script src="debug-console.js"></script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NHS GP Dashboard - ULTRA DEBUG MODE</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #005EB8 0%, #003087 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container { max-width: 1400px; margin: 0 auto; }

        .header {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #005EB8;
            margin-bottom: 10px;
        }

        /* Ultra Debug Console */
        .ultra-debug-panel {
            background: #0a0a0a;
            color: #00ff00;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            border: 2px solid #00ff00;
            position: relative;
            font-family: 'Courier New', monospace;
        }

        .ultra-debug-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #00ff00;
        }

        .ultra-debug-title {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .debug-stats {
            display: flex;
            gap: 20px;
            font-size: 12px;
        }

        .debug-stat {
            color: #ffff00;
        }

        #ultraDebugLog {
            background: #000;
            border: 1px solid #00ff00;
            padding: 15px;
            height: 500px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
        }

        .debug-line {
            margin: 2px 0;
            padding: 2px 5px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .debug-line.system { color: #00ffff; }
        .debug-line.info { color: #ffffff; }
        .debug-line.action { color: #ffff00; background: rgba(255,255,0,0.1); }
        .debug-line.api-send { color: #ff9800; background: rgba(255,152,0,0.1); }
        .debug-line.api-receive { color: #4caf50; background: rgba(76,175,80,0.1); }
        .debug-line.error { color: #ff0000; background: rgba(255,0,0,0.1); }
        .debug-line.success { color: #00ff00; background: rgba(0,255,0,0.1); }
        .debug-line.warning { color: #ffa500; }
        .debug-line.button { color: #ff00ff; background: rgba(255,0,255,0.1); }
        .debug-line.progress { color: #00ffff; border-left: 3px solid #00ffff; padding-left: 10px; }
        .debug-line.network { color: #9c27b0; }
        .debug-line.database { color: #2196f3; }

        .debug-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        .debug-controls button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }

        .debug-controls button:hover {
            background: #00dd00;
        }

        /* API Status Panel with Progress */
        .api-status-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        .api-status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .api-check {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f5f5f5;
            border-radius: 8px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .api-check.checking {
            background: #FFF3E0;
            border: 2px solid #FFB74D;
            animation: checking-pulse 1s infinite;
        }

        @keyframes checking-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .api-check.success {
            background: #E8F5E9;
            border: 2px solid #4CAF50;
        }

        .api-check.error {
            background: #FFEBEE;
            border: 2px solid #f44336;
        }

        .api-check input[type="checkbox"] {
            width: 24px;
            height: 24px;
            margin-right: 12px;
            cursor: not-allowed;
        }

        .api-check label {
            flex: 1;
            font-size: 14px;
            font-weight: 600;
        }

        .api-check .status {
            font-size: 11px;
            color: #666;
            position: absolute;
            bottom: 3px;
            right: 10px;
            font-style: italic;
        }

        .api-check .progress-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: #2196f3;
            transition: width 0.3s;
        }

        /* Search Section */
        .search-section {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #searchInput {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }

        #searchBtn, #testBtn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        #searchBtn {
            background: #005EB8;
            color: white;
        }

        #searchBtn:hover {
            background: #003087;
            transform: translateY(-2px);
        }

        #testBtn {
            background: #ff9800;
            color: white;
        }

        #testBtn:hover {
            background: #f57c00;
            transform: translateY(-2px);
        }

        /* ODS filter toggle */
        .search-box .filter-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 8px;
            font-size: 14px;
            color: #333;
            user-select: none;
        }

        /* Results Grid */
        #searchResults {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .surgery-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: all 0.3s;
        }

        .surgery-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
        }

        .modal-content {
            background: white;
            margin: 50px auto;
            padding: 30px;
            width: 90%;
            max-width: 1200px;
            border-radius: 12px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close-btn {
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: #999;
        }

        .close-btn:hover { color: #333; }

        .fetch-btn {
            background: #4CAF50;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-top: 20px;
        }

        .fetch-btn:hover {
            background: #45a049;
        }

        .loading { text-align: center; padding: 20px; color: #666; }
        .error { color: #f44336; padding: 20px; text-align: center; }
        .api-responses details { margin: 10px 0; }
        .api-responses summary { cursor: pointer; font-weight: 600; }
        .api-responses pre {
            background: #0b1020;
            color: #d6e4ff;
            padding: 12px;
            border-radius: 8px;
            overflow: auto;
            max-height: 300px;
            border: 1px solid #223344;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè• NHS GP Dashboard - ULTRA DEBUG MODE</h1>
            <p style="color: #666;">Complete Integration with Extensive Debugging</p>
        </div>

        <!-- Ultra Debug Console -->
        <div class="ultra-debug-panel">
            <div class="ultra-debug-header">
                <div class="ultra-debug-title">üîç ULTRA DEBUG CONSOLE</div>
                <div class="debug-stats">
                    <div class="debug-stat">Requests: <span id="requestCount">0</span></div>
                    <div class="debug-stat">Errors: <span id="errorCount">0</span></div>
                    <div class="debug-stat">Time: <span id="elapsedTime">0.000s</span></div>
                    <div class="debug-stat">Status: <span id="systemStatus">IDLE</span></div>
                </div>
            </div>
            <div id="ultraDebugLog"></div>
            <div class="debug-controls">
                <button onclick="clearDebugLog()">Clear Log</button>
                <button onclick="copyDebugLog()">Copy All</button>
                <button onclick="downloadDebugLog()">Download Log</button>
                <button onclick="toggleVerbosity()">Verbosity: <span id="verbosityLevel">MAX</span></button>
            </div>
        </div>

        <!-- API Status Checkboxes -->
        <div class="api-status-panel">
            <h3 style="margin-bottom: 10px;">API Status & Progress</h3>
            <div class="api-status-grid">
                <div class="api-check" id="check-supabase">
                    <input type="checkbox" id="cb-supabase" disabled>
                    <label for="cb-supabase">Supabase Connection</label>
                    <span class="status"></span>
                    <div class="progress-bar"></div>
                </div>
                <div class="api-check" id="check-database">
                    <input type="checkbox" id="cb-database" disabled>
                    <label for="cb-database">Database Tables</label>
                    <span class="status"></span>
                    <div class="progress-bar"></div>
                </div>
                <div class="api-check" id="check-edge">
                    <input type="checkbox" id="cb-edge" disabled>
                    <label for="cb-edge">Edge Functions</label>
                    <span class="status"></span>
                    <div class="progress-bar"></div>
                </div>
                <div class="api-check" id="check-cqc">
                    <input type="checkbox" id="cb-cqc" disabled>
                    <label for="cb-cqc">CQC API</label>
                    <span class="status"></span>
                    <div class="progress-bar"></div>
                </div>
                <div class="api-check" id="check-ods">
                    <input type="checkbox" id="cb-ods" disabled>
                    <label for="cb-ods">NHS ODS API</label>
                    <span class="status"></span>
                    <div class="progress-bar"></div>
                </div>
            </div>
        </div>

        <!-- Search Section -->
        <div class="search-section">
            <h2 style="margin-bottom: 20px;">Search GP Practices</h2>
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Enter surgery name or location...">
                <label class="filter-toggle" title="Only show results that already have an ODS code">
                    <input type="checkbox" id="filterOdsOnly">
                    Only show with ODS code
                </label>
                <button id="searchBtn" onclick="searchSurgeries()">Search</button>
                <button id="testBtn" onclick="testFullCycle()">Run Full Test</button>
            </div>
            <div id="searchResults"></div>
        </div>
    </div>

    <!-- Detail Modal -->
    <div id="detailModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeModal()">&times;</span>
            <div id="modalContent"></div>
        </div>
    </div>

    <script>
        // ============================================
        // ULTRA DEBUG SYSTEM
        // ============================================
        let requestCounter = 0;
        let errorCounter = 0;
        let startTime = Date.now();
        let debugLines = [];
        let verbosityLevel = 'MAX';
        let systemStatus = 'IDLE';
        let activeRequests = new Map();

        function ultraDebugLog(message, type = 'info', data = null, metadata = {}) {
            const now = new Date();
            const timestamp = now.toLocaleTimeString('en-GB', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            }).replace(/:/g, ':');

            const elapsed = ((now.getTime() - startTime) / 1000).toFixed(3);
            requestCounter++;

            if (type === 'error') errorCounter++;

            // Build detailed log line
            let logLine = `[${timestamp}] [#${String(requestCounter).padStart(4, '0')}] [${elapsed}s]`;

            // Add type indicator
            const typeIndicators = {
                'system': '‚öôÔ∏è SYSTEM',
                'action': 'üëÜ ACTION',
                'button': 'üîò BUTTON',
                'api-send': 'üì§ API-SEND',
                'api-receive': 'üì• API-RECV',
                'network': 'üåê NETWORK',
                'database': 'üíæ DATABASE',
                'error': '‚ùå ERROR',
                'success': '‚úÖ SUCCESS',
                'warning': '‚ö†Ô∏è WARNING',
                'progress': 'üìä PROGRESS',
                'info': '‚ÑπÔ∏è INFO'
            };

            logLine += ` [${typeIndicators[type] || type.toUpperCase()}]`;

            // Add metadata if present
            if (metadata.apiName) logLine += ` [${metadata.apiName}]`;
            if (metadata.method) logLine += ` [${metadata.method}]`;
            if (metadata.status) logLine += ` [STATUS:${metadata.status}]`;
            if (metadata.duration) logLine += ` [${metadata.duration}ms]`;
            if (metadata.step) logLine += ` [STEP:${metadata.step}]`;

            logLine += ` ${message}`;

            // Add data preview if present
            if (data) {
                if (typeof data === 'object') {
                    logLine += `\n    DATA: ${JSON.stringify(data, null, 2).split('\n').join('\n    ')}`;
                } else {
                    logLine += `\n    DATA: ${data}`;
                }
            }

            // Store debug line
            debugLines.push({
                timestamp: now,
                type: type,
                message: logLine,
                raw: message,
                data: data,
                metadata: metadata
            });

            // Update UI
            const debugLog = document.getElementById('ultraDebugLog');
            const debugLine = document.createElement('div');
            debugLine.className = `debug-line ${type}`;
            debugLine.textContent = logLine;
            debugLog.appendChild(debugLine);

            // Auto-scroll to bottom
            debugLog.scrollTop = debugLog.scrollHeight;

            // Update stats
            document.getElementById('requestCount').textContent = requestCounter;
            document.getElementById('errorCount').textContent = errorCounter;
            document.getElementById('elapsedTime').textContent = elapsed + 's';
            document.getElementById('systemStatus').textContent = systemStatus;

            // Keep only last 1000 lines for performance
            if (debugLines.length > 1000) {
                debugLines.shift();
                if (debugLog.firstChild) {
                    debugLog.removeChild(debugLog.firstChild);
                }
            }
        }

        // Intercept all network requests
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            const requestId = `REQ-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const url = args[0];
            const options = args[1] || {};
            const startTime = Date.now();

            ultraDebugLog(`Request initiated: ${url}`, 'api-send', {
                url: url,
                method: options.method || 'GET',
                headers: options.headers,
                body: options.body ? (typeof options.body === 'string' ? options.body : 'Binary data') : null
            }, {
                apiName: extractApiName(url),
                method: options.method || 'GET',
                step: 'INIT'
            });

            activeRequests.set(requestId, { url, startTime, status: 'pending' });
            systemStatus = 'ACTIVE';

            try {
                const response = await originalFetch.apply(this, args);
                const duration = Date.now() - startTime;

                let bodyText = '';
                try {
                    bodyText = await response.clone().text();
                } catch (e) {
                    bodyText = `[unreadable body: ${e.message}]`;
                }

                ultraDebugLog(`Response received: ${url}`, 'api-receive', {
                    status: response.status,
                    statusText: response.statusText,
                    headers: Object.fromEntries(response.headers.entries()),
                    body: bodyText
                }, {
                    apiName: extractApiName(url),
                    status: response.status,
                    duration: duration,
                    step: 'COMPLETE'
                });

                activeRequests.delete(requestId);
                if (activeRequests.size === 0) systemStatus = 'IDLE';

                return response;
            } catch (error) {
                const duration = Date.now() - startTime;

                ultraDebugLog(`Request failed: ${url} - ${error.message}`, 'error', {
                    error: error.message,
                    stack: error.stack
                }, {
                    apiName: extractApiName(url),
                    duration: duration,
                    step: 'FAILED'
                });

                activeRequests.delete(requestId);
                if (activeRequests.size === 0) systemStatus = 'ERROR';

                throw error;
            }
        };

        function extractApiName(url) {
            if (url.includes('/functions/v1/')) return 'EDGE-FUNCTION';
            if (url.includes('supabase.co')) return 'SUPABASE';
            if (url.includes('api.cqc.org.uk')) return 'CQC';
            if (url.includes('directory.spineservices.nhs.uk')) return 'NHS-ODS';
            return 'EXTERNAL';
        }

        // Extract ODS code from a variety of possible CQC response shapes
        function extractOdsCodeFromCqc(result) {
            try {
                // Normalise to the CQC payload object (sometimes nested, sometimes flat)
                const d = result?.data?.cqc_data ?? result?.data ?? null;
                if (!d) return '';

                // Try nested first, then flat, and both camelCase / snake_case variants
                const candidates = [
                    d?.location?.odsCode,
                    d?.provider?.odsCode,
                    d?.odsCode,
                    d?.location?.ods_code,
                    d?.provider?.ods_code,
                    d?.ods_code
                ].filter(Boolean).map(String);

                for (const raw of candidates) {
                    const normalized = normalizeOdsCode(raw);
                    if (normalized) return normalized;
                }
            } catch (_) { /* ignore */ }
            return '';
        }

        // Best-effort normalizer/validator for ODS codes (e.g., M83079, Y03664)
        function normalizeOdsCode(code) {
            if (!code) return '';
            const c = String(code).trim().toUpperCase();
            // Accept typical practice/organisation codes: letters+digits, 3‚Äì8 chars
            if (/^[A-Z0-9]{3,8}$/.test(c)) return c;
            return '';
        }

        // === Helper wait ===
        function delay(ms){ return new Promise(r => setTimeout(r, ms)); }

        // === Shallow compactor to drop only undefined (keeps nulls/strings/nums) ===
        function compact(obj){
            const out = {};
            Object.keys(obj || {}).forEach(k => {
                const v = obj[k];
                if (v !== undefined) out[k] = v;
            });
            return out;
        }

        // === Build an UPDATE payload from CQC JSON and persist as a safety net ===
        async function ensureRawCqcSavedToDb(locationId, phase1Result){
            try{
                const cqc = phase1Result?.data?.cqc_data || phase1Result?.data || null;
                if(!cqc || !locationId) return;

                const update = buildCqcUpdateFromJson(cqc);
                if(Object.keys(update).length === 0) return;

                ultraDebugLog('Persisting CQC JSON directly to DB (safety save)', 'database', { locationId, keys: Object.keys(update) }, { step: 'PHASE1-SAVE-CLIENT' });

                const { data, error } = await supabase
                    .from('CQC All GPs')
                    .update(update)
                    .eq('location_id', locationId)
                    .select('*');

                if(error){
                    ultraDebugLog('Client-side CQC save failed: ' + error.message, 'warning', { error });
                }else{
                    apiResponses.supabase_row = (Array.isArray(data) ? data[0] : data) || apiResponses.supabase_row;
                    ultraDebugLog('Client-side CQC save complete', 'success', { savedKeys: Object.keys(update) });
                }
            }catch(e){
                ultraDebugLog('Exception in ensureRawCqcSavedToDb: ' + (e?.message || e), 'warning');
            }
        }

        function buildCqcUpdateFromJson(cqc){
            // The edge function can return either:
            //   1) { location: {...}, provider: {...} }
            //   2) a flat Location-shaped object (no "location"/"provider" wrappers)
            // Handle both robustly.
            let loc = null, prov = null;

            const hasNested = !!(cqc?.location || cqc?.Location || cqc?.provider || cqc?.Provider);
            if (hasNested) {
                loc  = cqc?.location || cqc?.Location || null;
                prov = cqc?.provider || cqc?.Provider || null;
            } else {
                // Treat the top-level object as the Location
                loc  = cqc || null;
                prov = null;
            }

            // Pick up commonly nested sections, with flat fallbacks
            const ratingObj  = (loc?.currentRatings ?? cqc?.currentRatings) ?? null;
            const regulated  = (loc?.regulatedActivities ?? cqc?.regulatedActivities) ?? null;
            const inspAreas  = (loc?.inspectionAreas   ?? cqc?.inspectionAreas)   ?? null;
            const reports    = (loc?.reports            ?? cqc?.reports)           ?? null;

            // Try typical identifier shapes for the ODS code
            const odsCandidate = normalizeOdsCode(
                (loc?.odsCode || prov?.odsCode || cqc?.odsCode || loc?.ods_code || prov?.ods_code || cqc?.ods_code)
            ) || '';

            // Helper: prefer value from loc, then provider, then flat cqc
            const pick = (a, b, c) => (a !== undefined ? a : (b !== undefined ? b : c));

            const u = compact({
                // Raw JSON dumps (full-fidelity so we never lose information)
                location_source:        (loc  ? JSON.stringify(loc)  : (cqc ? JSON.stringify(cqc) : undefined)),
                provider_source:        (prov ? JSON.stringify(prov) : undefined),
                ratings:                ratingObj ? JSON.stringify(ratingObj) : undefined,
                regulated_activities:   regulated ? JSON.stringify(regulated) : undefined,
                inspection_areas:       inspAreas ? JSON.stringify(inspAreas) : undefined,
                reports:                reports ? JSON.stringify(reports) : undefined,

                // Key denormalised fields when safely available (loc ‚Üí prov ‚Üí flat)
                location_name:          pick(loc?.name,            prov?.name,            cqc?.name),
                provider_name:          pick(prov?.name,           null,                   cqc?.providerName),
                provider_id:            pick(loc?.providerId,      prov?.providerId,      cqc?.providerId),
                organisation_type:      pick(loc?.organisationType,loc?.type,             (cqc?.organisationType ?? cqc?.type)),
                location_type:          pick(loc?.type,            null,                   cqc?.type),
                region:                 pick(loc?.region,          null,                   cqc?.region),

                address_line_1:         pick(loc?.postalAddressLine1, null,                cqc?.postalAddressLine1),
                address_line_2:         pick(loc?.postalAddressLine2, null,                cqc?.postalAddressLine2),
                town_city:              pick(loc?.postalAddressTownCity, null,             cqc?.postalAddressTownCity),
                county:                 pick(loc?.postalAddressCounty, null,               cqc?.postalAddressCounty),
                postcode:               pick(loc?.postalCode,      null,                   cqc?.postalCode),
                uprn:                   pick(loc?.uprn,            null,                   cqc?.uprn),

                latitude:               (pick(loc?.onspdLatitude,  null, cqc?.onspdLatitude)  != null) ? String(pick(loc?.onspdLatitude, null, cqc?.onspdLatitude))  : undefined,
                longitude:              (pick(loc?.onspdLongitude, null, cqc?.onspdLongitude) != null) ? String(pick(loc?.onspdLongitude, null, cqc?.onspdLongitude)) : undefined,

                main_phone_number:      pick(loc?.mainPhoneNumber, null,                   cqc?.mainPhoneNumber),
                website:                pick(loc?.website,         null,                   cqc?.website),
                number_of_beds:         (typeof pick(loc?.numberOfBeds, null, cqc?.numberOfBeds) === 'number') ? pick(loc?.numberOfBeds, null, cqc?.numberOfBeds) : undefined,
                constituency:           pick(loc?.constituency,    null,                   cqc?.constituency),
                local_authority:        pick(loc?.localAuthority,  null,                   cqc?.localAuthority),
                inspection_directorate: pick(loc?.inspectionDirectorate, null,             cqc?.inspectionDirectorate),

                overall_rating:         ratingObj?.overall?.rating ?? undefined,
                last_inspection_date:   pick(loc?.lastInspection?.date, null,              cqc?.lastInspection?.date),
                last_report_date:       pick(loc?.lastReport?.publicationDate, null,       cqc?.lastReport?.publicationDate),

                location_types:         loc?.locationTypes        ? JSON.stringify(loc.locationTypes)        : (cqc?.locationTypes ? JSON.stringify(cqc.locationTypes) : undefined),
                gac_service_types:      loc?.gacServiceTypes      ? JSON.stringify(loc.gacServiceTypes)      : (cqc?.gacServiceTypes ? JSON.stringify(cqc.gacServiceTypes) : undefined),
                specialisms:            loc?.specialisms          ? JSON.stringify(loc.specialisms)          : (cqc?.specialisms ? JSON.stringify(cqc.specialisms) : undefined),
                inspection_categories:  loc?.inspectionCategories ? JSON.stringify(loc.inspectionCategories) : (cqc?.inspectionCategories ? JSON.stringify(cqc.inspectionCategories) : undefined),

                onspd_ccg_code:         pick(loc?.onspdCcgCode,    null,                  cqc?.onspdCcgCode),
                onspd_ccg_name:         pick(loc?.onspdCcgName,    null,                  cqc?.onspdCcgName),
                ods_ccg_code:           pick(loc?.odsCcgCode,      null,                  cqc?.odsCcgCode),
                ods_ccg_name:           pick(loc?.odsCcgName,      null,                  cqc?.odsCcgName),
                onspd_icb_code:         pick(loc?.onspdIcbCode,    null,                  cqc?.onspdIcbCode),
                onspd_icb_name:         pick(loc?.onspdIcbName,    null,                  cqc?.onspdIcbName),

                // Ensure ODS is captured if present anywhere in the CQC response
                ods_code:               odsCandidate || undefined,

                // Provider mirrored fields
                provider_region:                prov?.region ?? undefined,
                provider_website:               prov?.website ?? undefined,
                provider_main_phone_number:     prov?.mainPhoneNumber ?? undefined,
                provider_registration_status:   prov?.registrationStatus ?? undefined,
                provider_registration_date:     prov?.registrationDate ?? undefined,
                provider_type:                  prov?.type ?? undefined,
                ownership_type:                 prov?.ownershipType ?? undefined,
                provider_uprn:                  prov?.uprn ?? undefined,
                provider_latitude:              (prov?.onspdLatitude  != null) ? String(prov.onspdLatitude)  : undefined,
                provider_longitude:             (prov?.onspdLongitude != null) ? String(prov.onspdLongitude) : undefined,
                provider_constituency:          prov?.constituency ?? undefined,
                provider_local_authority:       prov?.localAuthority ?? undefined,
                provider_inspection_directorate:prov?.inspectionDirectorate ?? undefined,
                provider_address_line_1:        prov?.postalAddressLine1 ?? undefined,
                provider_address_line_2:        prov?.postalAddressLine2 ?? undefined,
                provider_town_city:             prov?.postalAddressTownCity ?? undefined,
                provider_county:                prov?.postalAddressCounty ?? undefined,
                provider_postcode:              prov?.postalCode ?? undefined,
                provider_region:                prov?.region ?? undefined,
                provider_location_ids:          prov?.locationIds ? JSON.stringify(prov.locationIds) : undefined,
                provider_inspection_areas:      prov?.inspectionAreas ? JSON.stringify(prov.inspectionAreas) : undefined,

                updated_at: new Date().toISOString()
            });

            return u;
        }

        // === Build an UPDATE payload from ODS JSON and persist as a safety net ===
        async function ensureRawOdsSavedToDb(locationId, phase2Result){
            try{
                const ods = phase2Result?.data?.ods_data || phase2Result?.data || null;
                if(!ods || !locationId) return;

                const update = buildOdsUpdateFromJson(ods);
                if(Object.keys(update).length === 0) return;

                ultraDebugLog('Persisting ODS JSON directly to DB (safety save)', 'database', { locationId, keys: Object.keys(update) }, { step: 'PHASE2-SAVE-CLIENT' });

                const { data, error } = await supabase
                    .from('CQC All GPs')
                    .update(update)
                    .eq('location_id', locationId)
                    .select('*');

                if(error){
                    ultraDebugLog('Client-side ODS save failed: ' + error.message, 'warning', { error });
                }else{
                    apiResponses.supabase_row = (Array.isArray(data) ? data[0] : data) || apiResponses.supabase_row;
                    ultraDebugLog('Client-side ODS save complete', 'success', { savedKeys: Object.keys(update) });
                }
            }catch(e){
                ultraDebugLog('Exception in ensureRawOdsSavedToDb: ' + (e?.message || e), 'warning');
            }
        }

        function buildOdsUpdateFromJson(ods){
            // Robustly extract the ODS code from various possible shapes
            // identifier can be an object, string, code field, or an array of identifiers
            let identVal = '';
            if (ods?.identifier?.value) {
                identVal = ods.identifier.value;
            } else if (Array.isArray(ods?.identifier)) {
                // find the NHS ODS organization code entry
                const match = ods.identifier.find(i => {
                    const sys = String(i?.system || '').toLowerCase();
                    return sys.includes('ods-organization-code') || sys.includes('ods-organisation-code') || sys.includes('ods');
                });
                identVal = match?.value || '';
            } else if (typeof ods?.identifier === 'string') {
                identVal = ods.identifier;
            } else if (ods?.code) {
                identVal = ods.code;
            }
            const odsNorm = normalizeOdsCode(identVal);

            // Extract telecom details (phone, url)
            const telecom = Array.isArray(ods?.telecom) ? ods.telecom : [];
            const phone = telecom.find(t => String(t?.system || '').toLowerCase() === 'phone')?.value || null;
            const websiteViaTelecom = telecom.find(t => String(t?.system || '').toLowerCase() === 'url')?.value || null;
            const website = ods?.website || websiteViaTelecom || null;

            // Extract address best-effort (FHIR style)
            const addr = Array.isArray(ods?.address) ? ods.address[0] : (ods?.address || null);
            const lineArr = Array.isArray(addr?.line) ? addr.line : [];
            const address_line_1 = addr?.line1 || lineArr[0] || addr?.addressLine1 || null;
            const address_line_2 = addr?.line2 || lineArr[1] || addr?.addressLine2 || null;
            const town_city = addr?.city || addr?.town || addr?.postalAddressTownCity || null;
            const postcode = addr?.postalCode || addr?.postcode || null;
            const county = addr?.county || null;
            const region = ods?.region || null;

            // Also capture the practice name if provided by ODS (will only be used by update() ‚Äì we are not forcing overwrites here)
            const odsName = ods?.name || null;

            // Build update payload:
            // - Always persist full raw ODS JSON for completeness
            // - Flattened fields included for practical querying
            const u = compact({
                nhs_ods_data: JSON.stringify(ods),
                last_nhs_update: new Date().toISOString(),
                // Flattened fields (safe to set; if you prefer not to overwrite existing, add a pre-fetch guard before update)
                ods_code: odsNorm || undefined,
                main_phone_number: phone || undefined,
                website: website || undefined,
                address_line_1: address_line_1 || undefined,
                address_line_2: address_line_2 || undefined,
                town_city: town_city || undefined,
                postcode: postcode || undefined,
                county: county || undefined,
                region: region || undefined,
                location_name: odsName || undefined
            });

            return u;
        }

        // Track all button clicks
        document.addEventListener('click', function(e) {
            if (e.target.tagName === 'BUTTON' || e.target.classList.contains('surgery-card')) {
                ultraDebugLog(`Button/element clicked: ${e.target.textContent || e.target.id || 'Unknown'}`, 'button', {
                    id: e.target.id,
                    className: e.target.className,
                    tagName: e.target.tagName,
                    position: { x: e.clientX, y: e.clientY }
                }, {
                    step: 'USER-INTERACTION'
                });
            }
        });

        // Track input changes
        document.addEventListener('input', function(e) {
            if (e.target.tagName === 'INPUT') {
                ultraDebugLog(`Input changed: ${e.target.id || 'Unknown'} = "${e.target.value}"`, 'action', {
                    id: e.target.id,
                    value: e.target.value,
                    type: e.target.type
                }, {
                    step: 'USER-INPUT'
                });
            }
        });

        function clearDebugLog() {
            ultraDebugLog('Debug log cleared by user', 'system');
            document.getElementById('ultraDebugLog').innerHTML = '';
            debugLines = [];
            requestCounter = 0;
            errorCounter = 0;
            startTime = Date.now();
        }

        function copyDebugLog() {
            const text = debugLines.map(l => l.message).join('\n');
            navigator.clipboard.writeText(text);
            ultraDebugLog('Debug log copied to clipboard', 'success');
        }

        function downloadDebugLog() {
            const text = debugLines.map(l => l.message).join('\n');
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ultra-debug-log-${new Date().toISOString()}.txt`;
            a.click();
            ultraDebugLog('Debug log downloaded', 'success');
        }

        function toggleVerbosity() {
            verbosityLevel = verbosityLevel === 'MAX' ? 'NORMAL' : 'MAX';
            document.getElementById('verbosityLevel').textContent = verbosityLevel;
            ultraDebugLog(`Verbosity level changed to: ${verbosityLevel}`, 'system');
        }

        // ============================================
        // SUPABASE & API CONFIGURATION
        // ============================================
        const SUPABASE_URL = 'https://unveoqnlqnobufhublyw.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVudmVvcW5scW5vYnVmaHVibHl3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUwMTcyNzYsImV4cCI6MjA3MDU5MzI3Nn0.g93OsXDpO3V9DToU7s-Z3SwBBnB84rBv0JMv-idgSME';

        ultraDebugLog('Initializing Supabase client', 'system', {
            url: SUPABASE_URL,
            keyLength: SUPABASE_ANON_KEY.length
        });

        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let currentSurgery = null;

        let apiResponses = { supabase_row: null, edge_response: null, cqc_data: null, ods_data: null };


        // Update API status with progress
        function updateApiStatus(apiId, status, message = '', progress = null) {
            ultraDebugLog(`API status update: ${apiId} -> ${status}`, 'progress', {
                api: apiId,
                status: status,
                message: message,
                progress: progress
            }, {
                apiName: apiId.toUpperCase(),
                status: status,
                step: 'STATUS-UPDATE'
            });

            const container = document.getElementById(`check-${apiId}`);
            const checkbox = document.getElementById(`cb-${apiId}`);
            const statusSpan = container.querySelector('.status');
            const progressBar = container.querySelector('.progress-bar');

            container.className = `api-check ${status}`;
            checkbox.checked = status === 'success';
            statusSpan.textContent = message;

            if (progress !== null) {
                progressBar.style.width = `${progress}%`;
            }
        }

        // Connection checks
        async function checkSupabaseConnection() {
            ultraDebugLog('Starting Supabase connection check', 'api-send', null, {
                apiName: 'SUPABASE',
                step: 'CONNECTION-TEST-START'
            });

            updateApiStatus('supabase', 'checking', 'Connecting...', 20);

            try {
                ultraDebugLog('Sending health check query to Supabase', 'database');

                const { data, error } = await supabase
                    .from('CQC All GPs')
                    .select('location_id')
                    .limit(1);

                if (error) {
                    throw error;
                }

                updateApiStatus('supabase', 'success', 'Connected', 100);
                ultraDebugLog('Supabase connection successful', 'success', {
                    tablesAccessible: true
                }, {
                    apiName: 'SUPABASE',
                    step: 'CONNECTION-SUCCESS'
                });
                return true;
            } catch (error) {
                updateApiStatus('supabase', 'error', 'Failed', 0);
                ultraDebugLog(`Supabase connection failed: ${error.message}`, 'error', {
                    error: error.message,
                    code: error.code,
                    details: error.details
                }, {
                    apiName: 'SUPABASE',
                    step: 'CONNECTION-FAILED'
                });
                return false;
            }
        }

        async function checkDatabaseTables() {
            ultraDebugLog('Starting database table check', 'database', null, {
                step: 'TABLE-CHECK-START'
            });

            updateApiStatus('database', 'checking', 'Checking...', 30);

            try {
                ultraDebugLog('Querying CQC All GPs table structure', 'database');

                // Check CQC table
                const { data: cqcData, error: cqcError } = await supabase
                    .from('CQC All GPs')
                    .select('*')
                    .limit(1);

                ultraDebugLog('CQC table query result', 'database', {
                    hasData: !!cqcData,
                    error: cqcError,
                    columns: cqcData && cqcData[0] ? Object.keys(cqcData[0]) : []
                });

                // Check for NHS columns
                const hasNHSColumns = cqcData && cqcData[0] && (
                    'nhs_ods_data' in cqcData[0]
                );

                ultraDebugLog('NHS column check', 'database', {
                    hasNHSColumns: hasNHSColumns,
                    availableColumns: cqcData && cqcData[0] ? Object.keys(cqcData[0]).filter(k => k.includes('nhs')) : []
                });

                if (!cqcError) {
                    const status = hasNHSColumns ? 'CQC + NHS Ready' : 'CQC Only';
                    updateApiStatus('database', hasNHSColumns ? 'success' : 'warning', status, 100);
                    ultraDebugLog(`Database tables available: ${status}`, hasNHSColumns ? 'success' : 'warning', null, {
                        step: 'TABLE-CHECK-COMPLETE'
                    });
                } else {
                    throw cqcError;
                }
            } catch (error) {
                updateApiStatus('database', 'error', 'No tables', 0);
                ultraDebugLog(`Table check failed: ${error.message}`, 'error', {
                    error: error
                }, {
                    step: 'TABLE-CHECK-FAILED'
                });
            }
        }

        async function checkEdgeFunctions() {
            ultraDebugLog('Starting edge function check', 'network', null, {
                apiName: 'EDGE-FUNCTION',
                step: 'EDGE-CHECK-START'
            });

            updateApiStatus('edge', 'checking', 'Testing...', 40);

            try {
                const testUrl = `${SUPABASE_URL}/functions/v1/fetch-nhs-data-complete`;
                ultraDebugLog(`Testing edge function at: ${testUrl}`, 'api-send');

                const response = await fetch(testUrl, {
                    method: 'GET',
                    headers: {
                        // Using anon key proves the function exists without invoking it
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                        'apikey': SUPABASE_ANON_KEY
                    }
                });

                ultraDebugLog(`Edge function response: ${response.status}`, 'api-receive', {
                    status: response.status,
                    ok: response.ok
                });

                if (response.ok || response.status === 404 || response.status === 405 || response.status === 401) {
                    updateApiStatus('edge', 'success', 'Deployed', 100);
                    ultraDebugLog('Edge functions ready', 'success', null, {
                        apiName: 'EDGE-FUNCTION',
                        step: 'EDGE-CHECK-SUCCESS'
                    });
                } else {
                    throw new Error(`Status ${response.status}`);
                }
            } catch (error) {
                updateApiStatus('edge', 'warning', 'Check pending', 50);
                ultraDebugLog(`Edge function check warning: ${error.message}`, 'warning', {
                    error: error.message
                }, {
                    apiName: 'EDGE-FUNCTION',
                    step: 'EDGE-CHECK-WARNING'
                });
            }
        }

        // Search functionality
        async function searchSurgeries() {
            const searchTerm = document.getElementById('searchInput').value.trim();

            ultraDebugLog(`Search initiated with term: "${searchTerm}"`, 'action', {
                searchTerm: searchTerm,
                termLength: searchTerm.length
            }, {
                step: 'SEARCH-START'
            });

            if (!searchTerm) {
                ultraDebugLog('Search aborted: No search term provided', 'warning');
                return;
            }

            systemStatus = 'SEARCHING';
            document.getElementById('searchResults').innerHTML = '<div class="loading">Searching...</div>';

            try {
                const filterOds = document.getElementById('filterOdsOnly')?.checked === true;

                ultraDebugLog(`Executing database query for: "${searchTerm}"`, 'database', {
                    table: 'CQC All GPs',
                    filter: `location_name.ilike.%${searchTerm}%`,
                    odsFilterApplied: filterOds
                });

                // Build the Supabase query, optionally restricting to rows with a real ODS code
                let query = supabase
                    .from('CQC All GPs')
                    .select('*')
                    .ilike('location_name', `%${searchTerm}%`)
                    .limit(12);

                if (filterOds) {
                    // exclude null and empty-string ODS codes at the database level
                    query = query.not('ods_code', 'is', null).neq('ods_code', '');
                }

                const { data, error } = await query;

                if (error) throw error;

                ultraDebugLog(`Search completed: Found ${data?.length || 0} results`, 'success', {
                    resultCount: data?.length || 0,
                    results: (data || []).map(d => ({ id: d.location_id, name: d.location_name }))
                }, {
                    step: 'SEARCH-COMPLETE'
                });

                displayResults(data || []);
                systemStatus = 'IDLE';

            } catch (error) {
                ultraDebugLog(`Search failed: ${error.message}`, 'error', {
                    error: error
                }, {
                    step: 'SEARCH-FAILED'
                });
                document.getElementById('searchResults').innerHTML = `<div class="error">Search failed: ${error.message}</div>`;
                systemStatus = 'ERROR';
            }
        }

        function displayResults(results) {
            ultraDebugLog(`Displaying ${results.length} search results`, 'info', null, {
                step: 'RENDER-RESULTS'
            });

            const html = results.map(surgery => `
                <div class="surgery-card" onclick="showDetails('${surgery.location_id}', '${surgery.ods_code || ''}')" data-id="${surgery.location_id}" data-ods-code="${surgery.ods_code || ''}">
                    <h3>${surgery.location_name}</h3>
                    <p><strong>Location ID:</strong> ${surgery.location_id}</p>
                    ${surgery.ods_code ? `<p><strong>ODS Code:</strong> ${surgery.ods_code}</p>` : ''}
                    <p><strong>Type:</strong> ${surgery.gac_service_types || 'N/A'}</p>
                    <p><strong>Region:</strong> ${surgery.region || 'N/A'}</p>
                </div>
            `).join('');

            document.getElementById('searchResults').innerHTML = html || '<p>No results found</p>';
        }

        async function showDetails(locationId, odsCode) {
            currentSurgery = { location_id: locationId, ods_code: odsCode };

            ultraDebugLog(`Opening details modal`, 'action', {
                locationId: locationId,
                odsCode: odsCode
            }, {
                step: 'MODAL-OPEN'
            });

            const modal = document.getElementById('detailModal');
            modal.style.display = 'block';
            document.getElementById('modalContent').innerHTML = '<div class="loading">Loading details...</div>';

            try {
                ultraDebugLog(`Fetching full details for ${locationId}`, 'database');

                const { data, error } = await supabase
                    .from('CQC All GPs')
                    .select('*')
                    .eq('location_id', locationId)
                    .single();

                if (error) throw error;

                // Enrich currentSurgery with CCG code from fetched row
                currentSurgery = {
                    location_id: data.location_id,
                    ods_code: data.ods_code || '',
                    ods_ccg_code: data.ods_ccg_code || ''
                };

                ultraDebugLog(`Details loaded for ${data.location_name}`, 'success', {
                    hasNHSData: !!(data.nhs_ods_data || data.nhs_prescribing_data),
                    dataKeys: Object.keys(data).filter(k => data[k] !== null)
                });

                document.getElementById('modalContent').innerHTML = `
  <h2>${data.location_name}</h2>
  <div class="api-toolbar" style="margin: 10px 0; display: flex; gap: 10px; flex-wrap: wrap;">
      <button class="fetch-btn" id="fetchAllBtn" onclick="fetchAllData()">üîÑ Fetch &amp; Save NHS + CQC</button>
      <button class="fetch-btn" style="background:#333" onclick="toggleRawJson(this)">Show raw JSON</button>
      <button class="fetch-btn" style="background:#2196f3" id="copyRawBtn" onclick="copyRawResponse()">Copy JSON</button>
  </div>

  <div id="summaryBlock" style="margin-top: 12px;"></div>

  <div id="apiResult" style="margin-top: 12px;"></div>

  <div id="rawApiResponse" style="display:none; margin-top: 12px;">
      <pre id="rawResponseContent"></pre>
  </div>
                `;

                // Seed summary and initial raw JSON with current Supabase row
                apiResponses.supabase_row = data;
                const summaryEl = document.getElementById('summaryBlock');
                if (summaryEl) summaryEl.innerHTML = renderQuickSummary(data, null);

                // Seed "raw JSON" with the current saved row so the button shows something even before fetching
                window.currentRawApiResponse = { saved_row: data };
                const rawPreInit = document.getElementById('rawResponseContent');
                if (rawPreInit) rawPreInit.textContent = JSON.stringify(window.currentRawApiResponse, null, 2);
            } catch (error) {
                ultraDebugLog(`Failed to load details: ${error.message}`, 'error', {
                    error: error
                });
                document.getElementById('modalContent').innerHTML = `<div class="error">Failed to load details: ${error.message}</div>`;
            }
        }

        async function fetchAllData() {
            if (!currentSurgery) return;

            ultraDebugLog(`=== STARTING TWO-PHASE NHS FETCH (CQC ‚Üí SAVE ‚Üí ODS) ===`, 'progress', {
                surgery: currentSurgery
            }, {
                step: 'FETCH-START'
            });

            systemStatus = 'FETCHING';

            // Initialize API statuses for two-phase flow
            updateApiStatus('cqc', 'checking', 'Calling...', 10);
            updateApiStatus('ods', 'checking', 'Waiting for CQC‚Ä¶', 0);

            let resultCqc = null;
            let resultOds = null;

            try {
                // ============================
                // PHASE 1: CQC ONLY
                // ============================
                const payload1 = {
                    location_id: currentSurgery.location_id,
                    ods_code: currentSurgery.ods_code,
                    ods_ccg_code: currentSurgery.ods_ccg_code || null,
                    data_sources: ['cqc']
                };

                ultraDebugLog(`Calling edge function (phase 1: CQC only)`, 'api-send', payload1, {
                    apiName: 'EDGE-FUNCTION',
                    method: 'POST',
                    step: 'PHASE1-SEND'
                });

                const resp1 = await supabase.functions.invoke('fetch-nhs-data-complete', {
                    body: payload1
                });

                resultCqc = resp1.data;

                ultraDebugLog(`Edge function response (phase 1)`, 'api-receive', {
                    status: resultCqc?.status,
                    sources: resultCqc?.data_sources_fetched
                }, {
                    apiName: 'EDGE-FUNCTION',
                    step: 'PHASE1-RECV'
                });

                if (resultCqc?.data?.cqc_data) {
                    updateApiStatus('cqc', 'success', 'Data received', 100);
                    ultraDebugLog('CQC data fetched successfully (phase 1)', 'success', {
                        dataSize: JSON.stringify(resultCqc.data.cqc_data).length
                    });
                } else {
                    updateApiStatus('cqc', 'error', resultCqc?.errors?.cqc || 'No data', 0);
                    ultraDebugLog('CQC data fetch failed (phase 1)', 'error', {
                        error: resultCqc?.errors?.cqc
                    });
                }

                if (resultCqc?.database_updated) {
                    ultraDebugLog('Database updated by CQC phase. Reloading row to capture new ODS/fields‚Ä¶', 'database');
                } else {
                    ultraDebugLog('CQC phase did not indicate database update. Reloading row anyway for safety‚Ä¶', 'database');
                }

                // Reload row after CQC save to get any newly derived fields (e.g., ODS)
                try {
                    const { data: row1, error: row1Err } = await supabase
                        .from('CQC All GPs')
                        .select('*')
                        .eq('location_id', currentSurgery.location_id)
                        .single();

                    if (row1Err) {
                        ultraDebugLog('Failed to reload saved row after CQC: ' + row1Err.message, 'warning', { error: row1Err });
                    } else {
                        apiResponses.supabase_row = row1;

                        // Refresh currentSurgery with any new ODS info saved from CQC phase
                        currentSurgery.ods_code = row1.ods_code || currentSurgery.ods_code || '';
                        currentSurgery.ods_ccg_code = row1.ods_ccg_code || currentSurgery.ods_ccg_code || '';

                        ultraDebugLog('Row reloaded after CQC save', 'database', {
                            ods_code: currentSurgery.ods_code,
                            ods_ccg_code: currentSurgery.ods_ccg_code
                        });
                    }
                } catch (e) {
                    ultraDebugLog('Exception while reloading row after CQC: ' + (e?.message || e), 'warning');
                }

                // Persist full CQC JSON to DB as a safety net (in case the edge function didn't)
                await ensureRawCqcSavedToDb(currentSurgery.location_id, resultCqc);

                // Small pause to allow DB triggers/replication to settle before ODS
                await delay(850);

                // If ODS code is still missing, try to extract it directly from the CQC response (in-memory handoff)
                if (!currentSurgery.ods_code) {
                    const extractedOds = extractOdsCodeFromCqc(resultCqc);
                    if (extractedOds) {
                        currentSurgery.ods_code = extractedOds;
                        ultraDebugLog('Using ODS code from CQC response (in-memory handoff)', 'info', { ods_code: currentSurgery.ods_code }, { step: 'PHASE1-ODS-HANDOFF' });
                    } else {
                        ultraDebugLog('No ODS code available after CQC phase (not in DB and not in response)', 'warning', null, { step: 'PHASE1-NO-ODS' });
                    }
                }

                // If we still have no ODS code at this point, skip phase 2 cleanly
                if (!currentSurgery.ods_code) {
                    updateApiStatus('ods', 'error', 'No ODS code ‚Äì skipping', 0);
                    ultraDebugLog('Skipping ODS phase: no ODS code available after CQC/DB reload', 'warning', {
                        location_id: currentSurgery.location_id
                    }, { step: 'PHASE2-SKIPPED' });

                    // Final reload to ensure latest CQC-saved state is reflected
                    try {
                        const { data: updatedRow, error: rowErr } = await supabase
                            .from('CQC All GPs')
                            .select('*')
                            .eq('location_id', currentSurgery.location_id)
                            .single();
                        if (!rowErr) {
                            apiResponses.supabase_row = updatedRow;
                        }
                    } catch (_) { /* ignore */ }

                    // Build and show the single combined RAW JSON object for the one-box viewer
                    apiResponses.edge_response = { phase1: resultCqc, phase2: null };
                    apiResponses.cqc_data = resultCqc?.data?.cqc_data ?? null;
                    apiResponses.ods_data = null;

                    window.currentRawApiResponse = {
                        phase1_cqc: resultCqc,
                        phase2_ods: null,
                        cqc: apiResponses.cqc_data,
                        ods: null,
                        saved_row: apiResponses.supabase_row || null
                    };

                    const rawPre = document.getElementById('rawResponseContent');
                    if (rawPre) rawPre.textContent = JSON.stringify(window.currentRawApiResponse, null, 2);

                    // Update summary block (will show ODS as "‚Äî")
                    const summaryEl = document.getElementById('summaryBlock');
                    if (summaryEl) {
                        summaryEl.innerHTML = renderQuickSummary(apiResponses.supabase_row || {}, null);
                    }

                    systemStatus = 'IDLE';
                    return; // do not proceed to phase 2
                }

                // ============================
                // PHASE 2: ODS ONLY
                // ============================
                updateApiStatus('ods', 'checking', 'Calling...', 30);

                const payload2 = {
                    location_id: currentSurgery.location_id,
                    ods_code: currentSurgery.ods_code,              // now potentially populated by the CQC phase
                    ods_ccg_code: currentSurgery.ods_ccg_code || null,
                    data_sources: ['ods']
                };

                ultraDebugLog(`Calling edge function (phase 2: ODS only)`, 'api-send', payload2, {
                    apiName: 'EDGE-FUNCTION',
                    method: 'POST',
                    step: 'PHASE2-SEND'
                });

                const resp2 = await supabase.functions.invoke('fetch-nhs-data-complete', {
                    body: payload2
                });

                resultOds = resp2.data;

                ultraDebugLog(`Edge function response (phase 2)`, 'api-receive', {
                    status: resultOds?.status,
                    sources: resultOds?.data_sources_fetched
                }, {
                    apiName: 'EDGE-FUNCTION',
                    step: 'PHASE2-RECV'
                });

                // Persist full ODS JSON to DB as a safety net
                await ensureRawOdsSavedToDb(currentSurgery.location_id, resultOds);

                if (resultOds?.data?.ods_data) {
                    updateApiStatus('ods', 'success', 'Data received', 100);
                    ultraDebugLog('ODS data fetched successfully (phase 2)', 'success', {
                        practiceName: resultOds.data.ods_data?.name,
                        address: resultOds.data.ods_data?.address
                    });
                } else {
                    updateApiStatus('ods', 'error', resultOds?.errors?.ods || 'No data', 0);
                    ultraDebugLog('ODS data fetch failed (phase 2)', 'error', {
                        error: resultOds?.errors?.ods
                    });
                }

                // Final reload of the saved row to reflect any ODS saves
                try {
                    const { data: updatedRow, error: rowErr } = await supabase
                        .from('CQC All GPs')
                        .select('*')
                        .eq('location_id', currentSurgery.location_id)
                        .single();

                    if (rowErr) {
                        ultraDebugLog('Failed to reload saved row at end: ' + rowErr.message, 'warning', { error: rowErr });
                    } else {
                        apiResponses.supabase_row = updatedRow;
                    }
                } catch (e) {
                    ultraDebugLog('Exception while final reload: ' + (e?.message || e), 'warning');
                }

                // Stash separate phase responses and convenient shortcuts
                apiResponses.edge_response = { phase1: resultCqc, phase2: resultOds };
                apiResponses.cqc_data = resultCqc?.data?.cqc_data ?? null;
                apiResponses.ods_data = resultOds?.data?.ods_data ?? null;

                // Build the single combined RAW JSON object for the one-box viewer
                const combinedRaw = {
                    phase1_cqc: resultCqc,
                    phase2_ods: resultOds,
                    cqc: apiResponses.cqc_data,
                    ods: apiResponses.ods_data,
                    saved_row: apiResponses.supabase_row || null
                };
                window.currentRawApiResponse = combinedRaw;

                // Update summary and raw JSON UI
                const summaryEl = document.getElementById('summaryBlock');
                if (summaryEl) {
                    // Pass edge-like object so renderQuickSummary can show ODS/CQC if present
                    summaryEl.innerHTML = renderQuickSummary(apiResponses.supabase_row || {}, { data: { ods_data: apiResponses.ods_data, cqc_data: apiResponses.cqc_data } });
                }

                const rawPre = document.getElementById('rawResponseContent');
                if (rawPre) rawPre.textContent = JSON.stringify(window.currentRawApiResponse, null, 2);

                ultraDebugLog(`=== TWO-PHASE FETCH COMPLETE ===`, 'success', {
                    databaseUpdated: !!(resultCqc?.database_updated || resultOds?.database_updated),
                    ods_code_after: currentSurgery.ods_code || '(empty)'
                }, {
                    step: 'FETCH-COMPLETE'
                });

                // Safety-persist any flattened fields missing in DB (ODS code, phone, website)
                try {
                    const phoneFromOds = Array.isArray(apiResponses.ods_data?.telecom)
                        ? apiResponses.ods_data.telecom.find(t => String(t?.system || '').toLowerCase() === 'phone')?.value
                        : null;
                    const phoneFromCqc = apiResponses.cqc_data?.mainPhoneNumber || null;
                    const phoneMaybe = phoneFromOds || phoneFromCqc || null;

                    const patch = {};
                    if (!apiResponses.supabase_row?.ods_code && currentSurgery.ods_code) patch.ods_code = currentSurgery.ods_code;
                    if (!apiResponses.supabase_row?.main_phone_number && phoneMaybe) patch.main_phone_number = phoneMaybe;
                    if (!apiResponses.supabase_row?.website && (apiResponses.cqc_data?.website)) patch.website = apiResponses.cqc_data.website;

                    if (Object.keys(patch).length) {
                        ultraDebugLog('Safety-persisting flattened fields missing in DB', 'database', patch, { step: 'FINAL-PATCH' });
                        const { data: patched, error: patchErr } = await supabase
                            .from('CQC All GPs')
                            .update(patch)
                            .eq('location_id', currentSurgery.location_id)
                            .select('*');

                        if (patchErr) {
                            ultraDebugLog('Final patch update failed: ' + patchErr.message, 'warning', { error: patchErr });
                        } else if (patched && patched[0]) {
                            apiResponses.supabase_row = patched[0];
                        }
                    }
                } catch (e) {
                    ultraDebugLog('Safety persist step exception: ' + (e?.message || e), 'warning');
                }

                systemStatus = 'IDLE';
            } catch (error) {
                ultraDebugLog(`Two-phase fetch failed: ${error?.message || error}`, 'error', {
                    error: error,
                    stack: error?.stack
                }, {
                    step: 'FETCH-FAILED'
                });

                ['cqc', 'ods'].forEach(api => {
                    updateApiStatus(api, 'error', 'Failed', 0);
                });

                systemStatus = 'ERROR';
            }
        }

        function closeModal() {
            ultraDebugLog('Modal closed by user', 'action', null, {
                step: 'MODAL-CLOSE'
            });
            document.getElementById('detailModal').style.display = 'none';
        }

        async function testFullCycle() {
            ultraDebugLog('========================================', 'system');
            ultraDebugLog('STARTING FULL INTEGRATION TEST', 'system');
            ultraDebugLog('========================================', 'system');

            systemStatus = 'TESTING';
            let testStep = 1;

            // Step 1: Check Supabase
            ultraDebugLog(`[TEST STEP ${testStep++}] Checking Supabase connection`, 'progress', null, {
                step: `TEST-${testStep-1}`
            });
            await checkSupabaseConnection();
            await new Promise(resolve => setTimeout(resolve, 500));

            // Step 2: Check Database
            ultraDebugLog(`[TEST STEP ${testStep++}] Checking database tables`, 'progress', null, {
                step: `TEST-${testStep-1}`
            });
            await checkDatabaseTables();
            await new Promise(resolve => setTimeout(resolve, 500));

            // Step 3: Check Edge Functions
            ultraDebugLog(`[TEST STEP ${testStep++}] Checking edge functions`, 'progress', null, {
                step: `TEST-${testStep-1}`
            });
            await checkEdgeFunctions();
            await new Promise(resolve => setTimeout(resolve, 500));

            // Step 4: Search
            ultraDebugLog(`[TEST STEP ${testStep++}] Performing test search for "Manchester"`, 'progress', null, {
                step: `TEST-${testStep-1}`
            });
            document.getElementById('searchInput').value = 'Manchester';
            await searchSurgeries();
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Step 5: Open first result
            let firstCard = document.querySelector('.surgery-card[data-ods-code]:not([data-ods-code=""])') || document.querySelector('.surgery-card');
            if (firstCard) {
                ultraDebugLog(`[TEST STEP ${testStep++}] Opening first search result`, 'progress', null, {
                    step: `TEST-${testStep-1}`
                });
                firstCard.click();

                // Step 6: Fetch all data
                await new Promise(resolve => setTimeout(resolve, 1000));
                ultraDebugLog(`[TEST STEP ${testStep++}] Fetching all NHS data`, 'progress', null, {
                    step: `TEST-${testStep-1}`
                });
                await fetchAllData();
            } else {
                ultraDebugLog('No search results to test', 'warning');
            }

            ultraDebugLog('========================================', 'system');
            ultraDebugLog('FULL INTEGRATION TEST COMPLETE', 'success');
            ultraDebugLog('========================================', 'system');
            systemStatus = 'IDLE';
        }

        // === Modal helpers for summary, raw JSON, copy ===
        function renderQuickSummary(row, edge) {
            if (!row) return '<div class="error">No data</div>';

            const name = row.location_name || row.provider_name || 'Unknown';
            const addressParts = [
                row.address_line_1,
                row.address_line_2,
                row.town_city,
                row.postcode
            ].filter(Boolean);
            const address = addressParts.join(', ') || 'No address on file';

            // Try to derive a rating from columns (overall_rating or JSON in current_ratings)
            let rating = row.overall_rating || '‚Äî';
            try {
                if (!rating && row.current_ratings) {
                    const cr = typeof row.current_ratings === 'string' ? JSON.parse(row.current_ratings) : row.current_ratings;
                    rating = cr?.overall?.rating || rating;
                }
            } catch (_) { /* ignore */ }

            const lastInspection = row.last_inspection_date
                ? ('' + row.last_inspection_date).split('T')[0]
                : '‚Äî';

            const ods = row.ods_code
                || (edge?.data?.ods_data?.identifier?.value)
                || '‚Äî';

            const phone = row.main_phone_number || row.phone_number || '‚Äî';
            const website = row.website || row.provider_website || '‚Äî';

            return `
      <div style="padding:12px; background:#f7fbff; border:1px solid #dde7f3; border-radius:8px;">
          <div style="font-size:18px; font-weight:600; color:#003087;">${name}</div>
          <div style="margin-top:6px">${address}</div>
          <div style="margin-top:6px; display:flex; gap:16px; flex-wrap:wrap;">
              <div><strong>Location ID:</strong> ${row.location_id || '‚Äî'}</div>
              <div><strong>ODS:</strong> ${ods}</div>
              <div><strong>Phone:</strong> ${phone}</div>
              <div><strong>Website:</strong> ${website}</div>
              <div><strong>Rating:</strong> ${rating}</div>
              <div><strong>Last inspection:</strong> ${lastInspection}</div>
          </div>
      </div>`;
        }

        function toggleRawJson(btn) {
            const box = document.getElementById('rawApiResponse');
            if (!box) return;
            const show = box.style.display !== 'block';
            box.style.display = show ? 'block' : 'none';
            if (btn) btn.textContent = show ? 'Hide raw JSON' : 'Show raw JSON';
            ultraDebugLog(`Raw JSON ${show ? 'shown' : 'hidden'}`, 'action');
        }

        function copyRawResponse() {
            try {
                const text = JSON.stringify(window.currentRawApiResponse ?? {}, null, 2);
                navigator.clipboard.writeText(text);
                ultraDebugLog('Raw JSON copied to clipboard', 'success');
            } catch (e) {
                ultraDebugLog('Failed to copy raw JSON: ' + (e?.message || e), 'error');
            }
        }

        // Initialize on page load
        window.onload = async () => {
            ultraDebugLog('========================================', 'system');
            ultraDebugLog('NHS GP DASHBOARD - ULTRA DEBUG MODE', 'system');
            ultraDebugLog('Version: 2.0.0', 'system');
            ultraDebugLog(`Timestamp: ${new Date().toISOString()}`, 'system');
            ultraDebugLog(`User Agent: ${navigator.userAgent}`, 'system');
            ultraDebugLog('========================================', 'system');

            ultraDebugLog('Dashboard initialization started', 'system');
            ultraDebugLog('Checking window.supabase availability', 'system', {
                available: !!window.supabase,
                version: window.supabase?.version
            });

            ultraDebugLog('Setting up event listeners', 'system');
            ultraDebugLog('Ready for user interaction', 'success');

            // Initial connection checks
            ultraDebugLog('Running initial system checks', 'progress');
            await checkSupabaseConnection();
            await checkDatabaseTables();
            await checkEdgeFunctions();

            ultraDebugLog('System ready - All checks complete', 'success');

            // Re-run search when ODS filter is toggled
            const odsFilterEl = document.getElementById('filterOdsOnly');
            if (odsFilterEl) {
                odsFilterEl.addEventListener('change', () => {
                    ultraDebugLog(`ODS filter toggled: ${odsFilterEl.checked ? 'ON' : 'OFF'}`, 'action', { checked: odsFilterEl.checked });
                    // If there's already text in the search box, re-run search to apply filter
                    if (document.getElementById('searchInput').value.trim()) {
                        searchSurgeries();
                    }
                });
            }

            systemStatus = 'READY';
        };
    </script>
</body>
</html>